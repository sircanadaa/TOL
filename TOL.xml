<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, May 21, 2015, 8:46 AM -->
<!-- MuClient version 4.79 -->

<!-- Plugin "TOL" generated by Plugin Wizard -->

<muclient>
<plugin
   name="TOL"
   author="Sonet"
   id="8065ca1ba19b529aee53ee44"
   language="Lua"
   save_state="y"
   date_written="2015-05-21 08:44:48"
   requires="4.79"
   version="1.171"
   >


<description trim="n">
<![CDATA[
-----------------------------------------------
-- Campaign specific commands
-----------------------------------------------
tcp | tcp <index>
      -- Without argument it goes to the first mob in the table, with it goes to that number
      -- Note this will also decide if it needs to be hunted or not all by its self
tcpo | tcpo <index> 
      -- Withough argument goest to the first mob in the alternate table
tqs
      -- Quick Scan
km
      -- Sends the kill command for the last mob queued up by aknx
pt
      -- Prints the table of mobs and room numbers
pto 
      -- Prints the other list of possible room cps
wm | wm <name>
      -- Quick where for a mob name or the last mob used with aknx
cpn <index> | <mob name>
      -- Hunt trick on the given index or mob name
kcpn 
      -- turns off hunt script

-----------------------------------------------
-- Quest specific commands
-----------------------------------------------
tq | tq <index> - not case sensitive
      -- Without argument it goes to the most probable quest room, with it goes to that room
nq - not case sensitive
      -- Runs to the next quest room
rq | rq all
      -- Without argument it shows most likely rooms, with it it shows all possible rooms
      
-----------------------------------------------
-- Other commands
-----------------------------------------------
xrt1 <area>
      -- runs to areas
tkey "<mob>" "<keywords>"
      -- Stores special keywords for a mob.
cp | gq end
      -- clears the miniwindow
tlookup name <name> level <number> room <roomname> area <areaname>
      -- This will look up mobs in the db.. 
      -- Any order and as little as one of these can be used
      -- Experimental currently
Note: 
  Adding a "Tstart" as in "mapper addnote Tstart" will tell TOL that this room is the begining of the area for this area
]]>
</description>
</plugin>
<!--  Get our standard constants -->

<include name="constants.lua"/>
  <timers>
  <timer
    name="execute_in_area_timer"
    script="execute_in_area_tick"
    enabled="n"
    second="0.25">
  </timer>
  <timer
    name="garbage_collection"
    script="collectgarbagenow"
    enabled="y"
    minute="5">
  </timer>
  </timers>
<!--  Aliases  -->

<aliases>
<alias
   enabled="y"
   match="^TOL debug on$"
   script="Toggle_Debug"
   regexp="y"
   sequence='100'
   >
  </alias>
   <alias
   enabled="y"
   match="^TOL debug off$"
   script="Toggle_Debug"
   regexp="y"
   sequence='100'
   >
 </alias>
 <alias
   match="^printVars$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="printVars"
   regexp="y"
  >
  </alias>
  <alias
   match="^[t|T][Q|q]$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="qGoto"
   regexp="y"
  >
  </alias>
  <alias
     match="^[t|T][q|Q] (\d*)$"
     enabled="y"
     send_to="12"
     sequence="100"
     script="qGotoIndex"
     regexp="y"
  >
  </alias>
  <alias
    match="^[n|N][q|Q]$"
    enabled="y"
    send_to="12"
    sequence="100"
    script="qNext"
    regexp="y"
  >
  </alias>
  <alias
    match="^[r|R][q|Q]$"
    enabled="y"
    send_to="12"
    sequence="100"
    script="qRooms"
    regexp="y"
  >
  </alias>  
  <alias
    match="^[r|R][q|Q] all$"
    enabled="y"
    send_to="12"
    sequence="100"
    script="qRoomsAll"
    regexp="y"
  >
  </alias>    
  <alias
    enabled="y"
    match="^qTest$"
    script="qTest"
    regexp="y"
    sequence='100'>
  </alias>
  <alias match="^(?:TOL) help$"
    enabled="y"
    sequence="100"
    send_to="12"
    regexp="y"
    keep_evaluating="y"   
  >
  <send>
    Note(getmemoryusage())
    ColourNote("MediumSeaGreen", "", GetPluginInfo (GetPluginID (), 3))
  </send>
  </alias>
  <alias
   match="^wm (.*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="whereMob"
   regexp="y"
  >
  </alias>
      <alias
   match="^wm$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="whereMob"
   regexp="y"
  >
  </alias>
      <alias
   match="^km$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="killMob"
   regexp="y"
  >
  </alias>
   <alias
   name="cp_check"
   script="cp_check"
   match="^(cp|campaign) (c|ch|che|chec|check)$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to='12'
  >
  <send>Send('cp check')
  EnableTrigger('camp_item_start', 1)</send>
  </alias>
  <alias
   name="gq_check"
   script="gq_check"
   match="^gq (c|ch|che|chec|check)$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to="12"
  >
  <send> EnableTrigger('camp_item_start', 1)
  </send>
  </alias> 
  <alias
   match="^tcp$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="gotoNextMob"
   regexp="y"
  >
  </alias>
  <alias
   match='^tkey \"(.*?)\" \"(.*?)\"$'
   enabled="y"
   send_to="12"
   sequence="100"
   script="add_Keywords"
   regexp="y"
  >
  </alias>
  <alias
   match="^tcpo (.*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="tcpohandler"
   regexp="y"
  >
  </alias>
  <alias
   match="^tcpo$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="tcpohandler"
   regexp="y"
  >
  </alias>
  <alias
   match="^tcp (\d*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="gotoIndexMob"
   regexp="y"
  >
  </alias>
  
  <alias match="^xru?n?to?1 (.+)$"
    enabled="y"
    sequence="100"
    script="xrun_to1"
    regexp="y"
  >
  </alias>
  <alias match="^xma?p?p?e?r?1 move (?<roomid>[0-9]+) ?(?<speed>run|walk)?$"
  enabled="y"
  sequence="95"
  script="move_trigger"
  regexp="y"
  >
  </alias>
  
    <alias
   match="^pt$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="printTable"
   regexp="y"
  >
  </alias>
   <alias
   match="^pto$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="printTable1"
   regexp="y"
  >
  </alias>
  <alias
   match="^(cp|campaign|gq|globalquest) end$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="cpgq_quit"
  >
  </alias>
<!-- the group that controlls the hunting aspects -->
<alias
   match="^cpn (.*?)$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="cpn_script"
  >
  </alias>
  <alias
   match="^cpn$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="cpn_script"
  >
  </alias>
  <alias
   match="^kcpn$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="hunt_off"
  >
  </alias>
   <alias
   match="^tqs$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="quickScan"
   regexp="y"
  >
  </alias>
  <alias
   match="^tlookup (.*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="lookup"
   regexp="y"
  >
  </alias>
</aliases>
<triggers>
   <trigger
   enabled="n"
   match="^You still have to kill (?&lt;num&gt;[\d]*)?\s?\* (?&lt;name&gt;.*?) \((?&lt;location&gt;.*?)(?&lt;dead&gt; - Dead|)\)(|\.)$"
   name="campaign_item"
   script="campaign_item"
   sequence="100"
   regexp="y"
   group="campaigncheck"
   omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="n"
  match="^Note\: One or more target names in this campaign|gquest might be slightly scrambled\.$"
  name="camp_item_start"
  script="camp_item_start"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
   name="reset_cp_flag"
   custom_colour="7"
   match="CONGRATULATIONS! You have completed your campaign."
   script="reset_cp_flag"
   enabled="y"
   send_to="12"
   sequence="100"
  >
   </trigger>
  <trigger
   enabled="y"
   regexp="y"
   match="^You get (.+) corpse of (.+)\.$"
   name="mobname"
   script="Add_To_Kill_Table"
   sequence="101"
  >
  </trigger>
  <trigger
   enabled="y"
   regexp="y"
   match="^\[(?:\d+)\] Your (.*?) (.*?)(?:\!|\.) \[(?:\d+)\]$"
   name="mobnamefight"
   script="mob_name"
   sequence="1"
  >
  </trigger>
  <trigger
   enabled="y"
   regexp="y"
   match="^Your (.*?) (.*?)(?:\!|\.) \[(?:\d+)\]$"
   name="mobnamefight1"
   script="mob_name"
   sequence="1"
  >
  </trigger>
   <trigger
   enabled="n"
   regexp="y"
   match="^Ayla gives you (.+) for the .+ corpse of (.+).$"
   name="saccorpse"
   script="mob_name"
   sequence="100"
  >
  </trigger>
 
  <trigger
  enabled="y"
  match="^(.*) tells you \'Good luck in your campaign\!\'$"
  name="camp_item"
  regexp='y'
  sequence='100'
  send_to='12'
  script="cp_check"
  omit_from_output="n"
  >
  <send>
  Send('cp check')
  EnableTrigger('camp_item_start', 1)
  timeStart()
  </send>
  </trigger>
<trigger 
    name="mob_dead"
    custom_colour="11"
    match="Congratulations, that was one of your CAMPAIGN mobs!"
    enabled="y"
    sequence="100"
    send_to="12"
    script="delete_mob_from_table"
  >
    <send>mob_index=2

    </send>
  </trigger>
  <!-- Was (?P<mob>[^0-9]){30,30} (?P<room>.+) -->
  <trigger 
    name="where_mob_trig"
    match= "^(?P<mob>[^0-9]{30,30}) (?P<room>.+)$" 
    enabled="n"
    sequence="1"
    keep_evaluating="y"
    send_to="12"
    regexp="y"
    script="where_mob_trig"
  >
  </trigger>
  
  <!-- trigers for the hunting scripts -->
  <trigger
   group="HUNTING"
   match="^You seem unable to hunt that target for some reason\.$"
   name="CPFound"
   regexp="y"
   send_to="12"
   script="CPFound"
   sequence="100"
  >
 </trigger>
  
  <trigger
   expand_variables="y"
   group="HUNTING"
   match="^You have no idea what you\'re doing\, but maybe (.*?) is (.*?)\?$"
   name="CPDoNext"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  </trigger>

  <trigger
   group="HUNTING"
   match="^(.*?) is here\!$"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  <send>
  </send>
  </trigger>
  <trigger
   group="HUNTING"
   match="^You are certain that .+ is .+ from here\.|You are almost certain that .+ is .+ from here\.|You are confident that .+ passed through here, heading .+\.|The trail of .+ is confusing, but you're reasonably sure .+ headed .+\.|There are traces of .+ having been here. Perhaps they lead .+\?|You have no idea what you\'re doing\, but maybe .+ is .+\?|You couldn\'t find a path to .+ from here\.|.+ is here\!$"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  </trigger>
  <trigger
   group="HUNTING"
   match="^No one in this area by the name \'(.*?)\'\.$"
   name="CPNotHere"
   regexp="y"
   send_to="12"
   sequence="100"
   script="not_here_script"
  >
  </trigger>
  <trigger
   group="HUNTING"
   match="^You couldn\'t find a path to (.*?) from here\.$"
   name="CPNoPath"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  <send>
</send>
  </trigger>
  <trigger
   group="HUNTING"
   match="^You have no idea what you\'re doing\, but maybe (.*?) left (.*?)\?$"
   regexp="y"
   script="incrementCounter"
   sequence="100"
  >
  <send>
</send>
  </trigger>
  <trigger
   group="Questing"
   match="^You are in area \: (.+)"
   name="questTestArea"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  
  </trigger>
  <trigger
   group="QuestI"
   enabled="y"
   match="^(.*) can be found in the vicinity of (.*) which$"
   name="QuestInfo"
   regexp="y"
   send_to="12"
   sequence="100"
   script="questRoom"
  >
  </trigger>
  <trigger
   group="QuestI"
   enabled="y"
   match="^You are on a quest to slay (.*)!$"
   name="QuestMob"
   regexp="y"
   send_to="12"
   sequence="100"
   script="questMob"
  >
  </trigger>
  <trigger  
   group="QuestI"
   enabled="y"
   match="^is in the general area of (.*).$"
   name="QuestInfoArea"
   regexp="y"
   send_to="12"
   sequence="100"
   script="questArea"
  >
  </trigger>
  <trigger
   group="Quest"
   enabled='y'
   match="^(.*) tells you \'of (.*?)\.\'$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  Send("q i")
  </send>
  </trigger>
  
  <trigger
   group="Quest"
   match="^QUEST\: You have almost completed your QUEST\!$"
   regexp="y"
   send_to="10"
   sequence="100"
  >
  </trigger>
  <trigger
   group="Quest"
   enabled="y"
   regexp="y"
   match="(.*)(\!|\.)  \[QUEST\]$"
   send_to="12"
   sequence="100"
   script="quest_color"
  >
  </trigger>
  <trigger
   group="Quest" 
   enabled="y"
   regexp="y"
   match="(.*)\[QUEST\]$"
   send_to="12"
   sequence="1"
   script="quest_color"
  >
  </trigger>
 
  
  
  <!-- Triggers for Global Quests   -->
  <trigger
  enabled="y"
  match="^Global Quest: Global quest # (?&lt;num&gt;\d*) for levels (\d*) to (\d*) - (.*) now started\.$"
  name="globalq_check"
  script="gq_check"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^Global Quest: Global quest # (?&lt;num&gt;\d*) for levels (\d*) to (\d*) has now started\.$"
  name="globalq_check1"
  script="gq_check"
  sequence='1'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^You have now joined Global Quest # (.*)\. See \'help gquest\' for available commands\.$"
  name="globalq_start"
  script="gq_start"
  sequence='1'
  regexp="y"
  omit_from_output="n"
  >/
  </trigger>
  <trigger
  enabled="y"
  match="^Congratulations\, that was one of the GLOBAL QUEST mobs\!$"
  name="globalq_delete"
  script="delete_mob_from_table"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^You were the first to complete this quest!|Global Quest: Global quest # (.*) (\(.*\))? is now over.|You are no longer part of Global Quest # (.*) and will be unable to rejoin.$"
  name="globalq_end"
  script="gq_end"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^You are not in a global quest.|You were the first to complete this quest!$"
  name="globalq_noton"
  script="gq_end"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  </triggers>
  <timers>
  <timer name="grbg" enabled="y" minute="59" second="0.00" offset_second="0.00"    send_to="12"
>
  <send>
   DebugNote(collectgarbage("count")*1024)
  collectgarbage("collect")
  DebugNote(collectgarbage("count")*1024)
  
   </send>

  </timer>
</timers>
<!--  Script  -->

<script>
<![CDATA[
dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

require "tprint"
require "KillTable"
require "pluginhelper"
require "serialize"
require "questhandle"
require "socket"

ThreadHolder= coroutine.running()
counter = tonumber(1)
counter1 = tonumber(1)

local Debug = false
currentRoom = {}
local char_status
local currentState
local tableNumHolder
local charname
local GQ_flag = false
local GQ_num
local started = false
mylevel = 0
mytier = 0
mobsleft= {}
cp_mobs= {}
local qmob

timestart= 0
timeend= 0
function hunt_off()
  Note('Turning off cpn script.')
  EnableTriggerGroup("HUNTING", false)
end
function getmemoryusage()
    collectgarbage('collect')
   return collectgarbage('count')
  end
function timeStart()
timestart = socket.gettime()
end
function timeEnd()
  timeend = socket.gettime()
  print ((timeend-timestart)/60)
end
function lookup(name1, line, wildcards)--Looks up mobs from the CPmobs database based off of name, level, area, or room
  local modifiers = {'name', 'level', 'area', 'room'}
  local ptr = 0
  local ptrkeep = 1
  local mobbuff ={}
  local decideQ = 0
  local level = 0
  local modanddata = {}
  for i, p in pairs (modifiers) do
    local x, a = 0
   a,x = string.find(wildcards[1], p.." ")
    if a ~= nil and x ~= nil then 
      
        
        tmp = string.sub (wildcards[1], x)
        ptr = string.len(tmp)
        for j, k in pairs(modifiers) do
          y, w = string.find(tmp, k.." ")
          if y~= nil and y< ptr then
            -- print (y)
            ptr = y -2
          end
        end
        modanddata[i] = string.sub(tmp, 2, ptr)
        prt = 1
      if x ~= nil and x > ptr then 
        ptr = x 
      end
       ptr = 0
    else 
      modanddata [i] = -1
    end
  end
  -- modanddata will always be in the form 1 = name, 2 = level, 3 = area, 4 = room
  local name =""
  local levela = 0
  local levelb = 0
  local room = ""
  local area = ""
  if modanddata[1] ~= -1 then --name
   name = modanddata[1] 
   decideQ = decideQ +1
  end
  if modanddata[2] ~= -1  then --level
    if tonumber(modanddata[2]) == nil then
      print ("Level needs to be a number")
      return
    end
   levela = tonumber(modanddata[2]) +11 
   levelb = tonumber(modanddata[2]) -11
   decideQ = decideQ + 9
  end
  if modanddata[3] ~= -1  then area = modanddata[3] decideQ = decideQ +12 end -- area
  if modanddata[4] ~= -1  then room = modanddata[4] decideQ = decideQ +15 end -- room
  --print (decideQ)
  if decideQ == 0 then print('Nothing found try something else or check your usage') return end
  if decideQ == 1 then -- name or default
    query = string.format("SELECT * from CPMobs where name like %s", fixsql(name))
  elseif decideQ == 9 then-- level only
    query = string.format("SELECT * from CPMobs where level <= %d and level >= %d", levela, levelb)
  elseif decideQ == 12 then -- area only
    query = string.format("SELECT * from CPMobs where area_name like %s", fixsql(area))
  elseif decideQ == 15 then -- room only
    query = string.format("SELECT * from CPMobs where room_name like %s", fixsql(room))
  elseif decideQ == 10 then -- name and level
    query = string.format("SELECT * from CPMobs where name like %s and level <= %d and level >= %d", fixsql(name), levela, levelb)
  elseif decideQ == 13 then -- name and area
    query = string.format("SELECT * from CPMobs where name like %s and area_name like %s", fixsql(name), fixsql(area))
  elseif decideQ == 16 then -- name and room
    query = string.format("SELECT * from CPMobs where name like %s and room_name like %s", fixsql(name), fixsql(room))
  elseif decideQ == 21 then -- level and area
    query = string.format("SELECT * from CPMobs where level <= %d and level >= %d and area_name like %s",levela, levelb, fixsql(area))
  elseif decideQ == 24 then -- level and room
    query = string.format("SELECT * from CPMobs where level <= %d and level >= %d and room_name like %s", levela, levelb, fixsql(room))
  elseif decideQ == 27 then -- area and room this shouldn't really happen but fuck it, its an option now
    query = string.format("SELECT * from CPMobs where area_name like %s and room_name like %s", fixsql(area), fixsql(room))
  elseif decideQ == 25 then -- name, level, room
    query = string.format("SELECT * from CPMobs where name like %s and level <= %d and level >= %d and room_name like %s", fixsql(name), levela, levelb, fixsql(room))
  elseif decideQ == 37 then -- name, level, room, area
    query = string.format("SELECT * from CPMobs where name like %s and level <= %d and level >= %d and room_name like %s and area_name like %s", fixsql(name), levela, levelb,fixsql(room), fixsql(area))
  elseif decideQ == 28 then -- name, room, area
    query = string.format("SELECT * from CPMobs where name like %s and room_name like %s and area_name like %s", fixsql(name), fixsql(room), fixsql(area))
  elseif decideQ == 22 then -- name, level, area 
    query = string.format("SELECT * from CPMobs where name like %s and level <= %d and level >= %d and area_name like %s", fixsql(name), levela, levelb, fixsql(area))
  elseif decideQ == 36 then -- level, room, area
    query = string.format("SELECT * from CPMobs where level <= %d and level >= %d and room_name like %s and area_name like %s", levela, levelb,fixsql(room), fixsql(area))

  end
  for p in dbkt:nrows(query) do
    table.insert(mobbuff, p )
  end
  tprint (mobbuff)
  if decideQ == 1 and #mobbuff <1 then 
    -- print ('test')
    query = string.format("SELECT * from mobkills where name like %s group by room_id", fixsql(name))
    for p in dbkt:nrows(query) do
      table.insert(mobbuff, p)
    end
  end
  if #mobbuff<1 then
    print ("OKYDOKY BOSS NOTHING TO SEE HERE")
    print ("seriously though we found nothing")
  end
end
function quickScan()
  Execute("scan " .. mobname)
end

function Toggle_Debug(name, line, wildcards)
  if string.find(line, "on") then
    Note ("Turning Debugging on")
    Debug = true
  else
    Note ("Turning Debugging off")
    Debug = false
  end
end

function QuestInfoHandle(name, line, wildcards)
 -- qMob(wildcards[1])
  qRoom(wildcards[2])
 -- mobname = sanitizeName(wildcards[1])
end

function QuestInfoHandleArea(name, line, wildcards)
  qArea(wildcards[1])
end

function questMob(name, line, wildcards)
  qMob(wildcards[1])
  mobname = sanitizeName(wildcards[2])
end

function questRoom(name, line, wildcards)
    qRoom(wildcards[2])
end

function questArea(name, line, wildcards)
    qArea(wildcards[1])
end

function cp_check( name, line, wildcards)
  EnableTrigger("campaign_item", true)
  mobsleft = {}
end -- cp_check

function gq_check( name, line, wildcards)
  DebugNote( "gq_check")
  DebugNote(wildcards)
  GQ_flag = true
  EnableTrigger('camp_item_start', 1)
  DebugNote("GQ_flag set to "..tostring(GQ_flag))
  if wildcards ~= nil and tonumber(GQ_num) == tonumber(wildcards.num) then
    EnableTrigger("campaign_item", true)
    DebugNote("Gquest started")
    GQ_num = tonumber(wildcards[1])
    DebugNote (GQ_num)
    Send("gq ch")
    mobsleft = {}

  elseif #wildcards <=1 then
    EnableTrigger("campaign_item", true)
    Send("gq ch")
    mobsleft = {}
  elseif tonumber(wildcards.num) ~= tonumber(GQ_num) then
    GQ_flag = false
    DebugNote("Shutting GQ_flag off")
    EnableTrigger('camp_item_start', 0)
  end
end -- gq_check

function gq_start(name, line, wildcards)
  DebugNote ("gq_start")
  --EnableTrigger("campaign_item", true)
  GQ_num = tonumber(wildcards[1])
  DebugNote (GQ_num)
  GQ_flag = true
  DebugNote("GQ_flag set to "..tostring(GQ_flag))
  mobsleft = {}
end

function cpgq_quit(name, line, wildcards)
  DebugNote(name)
  DebugNote(line)
  DebugNote(wildcards)
  if wildcards[1] == "gq" then
    GQ_flag = false
    DebugNote("GQ_flag set to "..tostring(GQ_flag))
  end
  DebugNote("cpgq_quit")
  phelper:broadcast(4)
  cp_mobs = {}
  clearTable()
end

function gq_end(name, line, wildcards)
DebugNote(wildcards)
  if GQ_flag == false then return end
  if wildcards[1] == GQ_num then
    DebugNote("if block")
    GQ_flag = false
    DebugNote("GQ_flag set to "..tostring(GQ_flag))
    phelper:broadcast(4)
    cp_mobs = {}
    clearTable()
  elseif #wildcards<1 then 
    DebugNote("elseif block")
    GQ_flag = false
    DebugNote("GQ_flag set to "..tostring(GQ_flag))
    phelper:broadcast(3)
  end -- if
  DebugNote ("Gq is off now")
end

function add_Keywords(name, line, wildcards)
  if check_CPMobs_Table()<1 then 
    print ("you don't have CPMobs table, you can't use this function, try installing the CPMobs plugin")
    return 
  end
  query = string.format("UPDATE CPMobs SET keywords=%s WHERE name=%s;", fixsql(wildcards[2]), fixsql(wildcards[1]))
  querycheck = string.format("Select count(name) as count from CPMobs where name= %s;",fixsql(wildcards[1]))
  for a in dbkt:nrows(querycheck) do 
    count = a.count
    if count<1 then 
      print ("You have the name wrong, or it is not in the table, try again!")
      print ("You entered: " .. wildcards[1])
    end
  end
  if tonumber(count)<1 then
    return 
  end
  rc= dbkt:exec(query)
  print ("Added ".. wildcards[2].. " to the mob entry for ".. wildcards[1])
  if rc ~= 0 then
    Note ( DatabaseError('dbkt'))
  end--if
end

function check_CPMobs_Table()
  local count = 0
  if dbkt:isopen() then
    checktable = "SELECT Count(name) as count FROM sqlite_master WHERE type='table' AND name='CPMobs';"
    for a in dbkt:nrows(checktable) do
      count = a.count
    end
    if count <1 then 
        
        return 0
    end
    return 1
  else
    print('You either have not moved rooms or have not installed the CPMobs plugin. Try one of those first.')
  end
end

function camp_item_start()-- get your campaign items
  clearTable()
  
  EnableTrigger('campaign_item',false)
  EnableTrigger('camp_item_start',0)
  cp_mobs = {}
  cp_mobs= mobsleft
  if myThread== nil  or coroutine.status (myThread) == "dead" then

        myThread = coroutine.create(buildRoomTable)
        AddTimer ("tickler", 0, 0, .1, "",
               timer_flag.Enabled + timer_flag.Replace,
               "tickle_it")

  end--if 
    FirstRun_cp_var= false
    check_dead()
    DebugNote(collectgarbage("count")*1024)
    collectgarbage("collect")
    DebugNote(collectgarbage("count")*1024)
    
end

function campaign_item (name, line, wildcards)-- the actual campaign item getter
  DebugNote("start cp_item mobsleft")
  DebugNote (wildcards)
  DebugNote("end cp_item mobsleft")
  name = wildcards.name
  mobdead = false
  location = wildcards.location
  num = tonumber(wildcards.num)
  if wildcards.dead ==  ' - Dead' then
    mobdead = true
  else
    mobdead = false
  end
  
  if not name or not location then
    print("error parsing line: ", line)
  else
    table.insert(mobsleft, {name=name, location=location, mobdead=mobdead, mobdead=mobdead,false, num = tonumber(num)})
  end
  end -- campaign_item

function delete_mob_from_table( )
  local found = false
  local tmp = {}
  local num
  if AutoUpdate_var == false and last_Enemy~= nil then
    for p,q in pairs (room_num_table) do
      num = tonumber(q[6]) or 1
      DebugNote (q)
      DebugNote(q[6])
      DebugNote ("Number of kills needed at time of delete_mob_from_table "..num)
      if string.lower(last_Enemy)== string.lower(q[2]) and num == 1 then
        table.remove(room_num_table,  p)
        table.remove(cp_mobs, p)
        found = true
        break
      elseif string.lower(last_Enemy)== string.lower(q[2]) then
        q[6] = q[6]-1
        cp_mobs[p].num = cp_mobs[p].num -1
        DebugNote(cp_mobs)
        DebugNote(cp_mobs[p][q])
        DebugNote ("number of mobs is ".. q[6])
        found = true
        break
      end--if
    end--for
    for p,q in pairs (room_num_table2) do
       if string.lower(last_Enemy)== string.lower(q[2]) then
        room_num_table2[p] = nil
        else 
          table.insert(tmp, room_num_table2[p])
        end--if
    end--for
    room_num_table2 = tmp
    if found == false then
      DebugNote("Begin cp_mobs[mob_next_delete_value] check")
      DebugNote(num)
      DebugNote("End cp_mobs[mob_next_delete_value] check")
      table.remove(room_num_table,  mob_next_delete_value)
      table.remove(cp_mobs, mob_next_delete_value)
      DebugNote(GQ_flag)
      if GQ_flag == true then
        do_Execute_no_echo("gq check")
      else
        do_Execute_no_echo("cp check")
      end--if
    end--if
    mob_index= 1
  end--if
  check_diff()
  sortRoomCPByPath()
  var.cp_mobs = serialize.save( "cp_mobs", cp_mobs )
  phelper:broadcast(1, var.cp_mobs)
  DebugNote(collectgarbage("count")*1024)
  collectgarbage("collect")
  DebugNote(collectgarbage("count")*1024)
end

function delete_mob_from_table_index(val)
  if AutoUpdate_var == false and last_Enemy ~= nil then
  for p,q in pairs (room_num_table2) do
    num = tonumber(q[6]) or 1
     if string.lower(last_Enemy)== string.lower(q[2]) then
        table.remove(room_num_table2,  p)
      end--if
  end--for
  if room_num_table[val].num == 1 then
    table.remove(room_num_table, tonumber(val))
  else
    room_num_table[val][6] = room_num_table[val][6] -1
    cp_mobs[val].num = cp_mobs[val].num -1
  end 
  DebugNote(collectgarbage("count")*1024)
  collectgarbage("collect")
  DebugNote(collectgarbage("count")*1024)
  mob_index= 1
  check_diff()
  end--if
end

function CPFound()
  if tonumber(count) >0 then
  Execute ("wm " .. count .. "." ..mobname)
  else
  Execute ("wm "  ..mobname)
  end
  EnableTriggerGroup("HUNTING", false)
end

function not_here_script()
  Execute("wm "..mobname)
  Note ("THIS IS NOT THE CORRECT AREA OR THE MOB IS DEAD")
  EnableTriggerGroup("HUNTING", false)
  
end

function quest_color()
  ColourNote ("white","blue","==================QUEST MOB HERE!!!!!!!!!!!!!!!!!!!!!!!=================")
end

function cpn_script (index, line, wildcards)
  -- print (index)
  -- print (line)
  local numcheck
  if wildcards ~= nil then
    numcheck = tonumber(wildcards[1])
  end
  DebugNote (index)
  DebugNote (type(index))
  DebugNote (numcheck)
    if  index ~= nil and type(index)== 'string'  then
        if #wildcards < 1 then 
          index = mob_index

        elseif #wildcards <=1 and numcheck == nil then

          EnableTriggerGroup("HUNTING", true)
          reset_counter()
          mobname = wildcards[1]
          Execute ("hunt " .. mobname)
          --EnableTriggerGroup("HUNTING", false)
          return
        end
      if wildcards[1]== nil and mob_index ~= nil then
      else
      index = wildcards[1]
      end
    end --if
index = tonumber(index)
if room_num_table[index] == nil then
  print ("No cp_mob at that value")
  return
end--if
  EnableTriggerGroup("HUNTING", true)
  reset_counter()
  if room_num_table[index][1] ~= nil and cpn_is_room_type == false then
    getTable(index)
    Execute ("hunt " .. mobname)
  else
    Note("Either not on a cp or haven't checked it yet, or its a room type cp. Use hyperlink.")
    cpn_is_room_type= false
    EnableTriggerGroup("HUNTING", false)
  end
end

AutoUpdate_var = false
greedy = false
FirstRun_cp_var= true
-- This function is just for testing. It should never actually be used.
function printVars()
  tprint (cp_mobs)
--   Debug = true
--   DebugNote({1, 2})
--   Debug = false
--   --Clean_Kill_Table()
-- cp_mobs[1]={location= 'Stairwell'
-- ,mobdead= 'false',
-- name= 'King Breolerc',
-- clean = 'King Breolerc'}
-- cp_mobs[2]={location= 'The Conservatory'
-- ,mobdead= 'false',
-- name= 'a rabbit foot fern',
-- clean = 'a rabbit foot fern'}
-- cp_mobs[3]={location= 'North West Market Square'
-- ,mobdead= 'false',
-- name= 'Mino the Crazy',
-- clean = 'mino the crazy'}
-- cp_mobs[4]={location= 'High priest quarters'
-- ,mobdead= 'false',
-- name= 'an ancient ghost',
-- clean = 'an ancient ghost'}
local llthreads = require"llthreads"
print (package.cpath)
local thread_code = [[
temp= ''
-- local socket = require"socket"
--     -- print thread's parameter.
--     --dofile ("E:\\Users\\Jeremy\\Desktop\\r1802\\MUSHclient\\worlds\\plugins\\TOL\\luapath.lua")
-- -- temp = (package.cpath)
   local status, socket = pcall(require,"socket")
    local db = pcall(require,"lsqlite3")
--     -- if temp ~='' then
--     -- temp = (package.cpath) end
--     return status, socket
--   --   print("CHILD: received params:", ...)
    local tst=sqlite3.open('E:\\Users\\Jeremy\\Desktop\\r1802\\MUSHclient\\worlds\\plugins\\TOL\\KillTable.db')
--   --   local temp
    querycheck = "Select count(name) as count from CPMobs "
  for a in tst:nrows(querycheck) do 
    temp =a.count 
  end
--   --   -- print(tst)
--   --   -- return all thread's parameters back to the parent thread.
    return temp
]]


-- create detached child thread.
-- local thread = llthreads.new(thread_code, "number:", 12345, "nil:", nil, "bool:", true)
-- start non-joinable detached child thread.
-- assert(thread:start(true))
-- Use a detatched child thread when you don't care when the child finishes.
local function print_thread(...)
  local thread = llthreads.new([[ print("print_thread:", ...); ]], ...)
  -- start joinable thread
  assert(thread:start())
  return thread
end

local thread2 = print_thread("number:", 1234, "nil:", nil, "bool:", true)
print("thread2:join: results # = ", select('#', thread2:join()))
-- create child thread.
local thread = llthreads.new(thread_code, "test:", 1111)
-- start joinable child thread.
assert(thread:start())
-- Warning: If you don't call thread:join() on a joinable child thread, it will be called
-- by the garbage collector, which may cause random pauses/freeze of the parent thread.
-- luastmt = "gmcpdata = " .. thread:join()
--         assert (loadstring (luastmt or "")) ()
-- print(gmcpdata)
--print("thread:join: results # = ", select('3', thread:join()))
print("PARENT: child returned: ", thread:join())
--tprint (select('3', thread:join())
-- local socket = require"socket"
-- socket.sleep(2) -- give detached thread some time to run.
if myThread== nil  or coroutine.status (myThread) == "dead" then

        myThread = coroutine.create(buildRoomTable)
        AddTimer ("tickler", 0, 0, .1, "",
               timer_flag.Enabled + timer_flag.Replace,
               "tickle_it")
      end--if 
 tprint(cp_mobs) 
 tprint(room_num_table)

DebugNote(collectgarbage("count")*1024)
DebugNote("Mem Usage " .. collectgarbage("count"))
DebugNote(collectgarbage("count")*1024)
 phelper:broadcast(4)
 --test
-- collectgarbage("count")
end
-- end testing function
kill_info = {}
-- I hate to do it this way and will come up with a better solution... but for now
damage_verbs = {'misses ',
' tickles ',
' bruises ',
' scratches ',
' grazes ',
' nicks ',
' blasts',
' scars ',
' hits ',
' injures ',
' wounds ',
' mauls ',
' maims ',
' mangles ',
' mars ',
' massacres ',
' dismembers ',
' devastates ',
' disembowels ',
' lacerates ',
' LACERATES ',
' DECIMATES ',
' DEVASTATES ',
' ERADICATES ',
' OBLITERATES ',
' EXTIRPATES ',
' INCINERATES ',
' MUTILATES ',
' DISEMBOWELS ',
' MASSACRES ',
' DISMEMBERS ',
' RENDS ',
' meteorites ',
' glaciates ',
' nukes ',
' implodes ',
' asphyxiates ', --
' liquidates ', -- 
' fissures ', --
' exterminates ', --
' ravages ', --
' atomizes ', --
' sunders ', --
' tears into ', --
' destroys ', --
' pulverizes ', --
' demolishes ', --
' mutilates ', --
' incinerates ', --
' extirpates ', --
' obliterates ', --
' eradicates ', --
' annihilates ',-- nnih%
' evaporates ',-- vapor%
' ruptures ',-- upt%
' shatters ',-- hatter%
' slaughters ', -- laughters%
' vaporizes ',--vapor%
' wastes ',-- astes%
' shreds ',
' cremates ', -- remat%
' supernovas ',
' The charge slams into ',
' does UNSPEAKABLE things to ',
' does UNTHINKABLE things to ',
' does UNIMAGINABLE things to ',
' does UNBELIEVABLE things to ',
' %- BLASTS %- ',
' %-= DEMOLISHES =%- ',
' %*%* SHREDS %*%* ',
' %*%*%*%* DESTROYS %*%*%*%* ',
' %*%*%*%*%* PULVERIZES %*%*%*%*%* ',
' %-=%- VAPORIZES %-=%- ',
' <%-==%-> ATOMIZES <%-==%-> ',
' <%-:%-> ASPHYXIATES <%-:%-> ',
' <%-%*%-> RAVAGES <%-%*%-> ',
' <>%*<> FISSURES <>%*<> ',
' <%*><%*> LIQUIDATES <%*><%*> ',
' <%*><%*><%*> EVAPORATES <%*><%*><%*> ',
' <%-=%-> SUNDERS <%-=%-> ',
' <=%-=><=%-=> TEARS INTO <=%-=><=%-=> ',
' <%->%*<=> WASTES <=>%*<%-> ',
' <%-%+%-><%-%*%-> CREMATES <%-%*%-><%-%+%-> ',
' <%*><%*><%*><%*> ANNIHILATES <%*><%*><%*><%*> ',
' <%-%-%*%-%-><%-%-%*%-%-> IMPLODES <%-%-%*%-%-><%-%-%*%-%-> ',
' <%-><%-=%-><%-> EXTERMINATES <%-><%-=%-><%-> ',
' <%-==%-><%-==%-> SHATTERS <%-==%-><%-==%-> ',
' <%*><%-:%-><%*> SLAUGHTERS <%*><%-:%-><%*> ',
' <%-%*%-><%-><%-%*%-> RUPTURES <%-%*%-><%-><%-%*%-> ',
' <%-%*%-><%*><%-%*%-> NUKES <%-%*%-><%*><%-%*%-> ',
' %-<%[=%-%+%-=%]<:::<>:::> GLACIATES <:::<>:::>%[=%-%+%-=%]>%- ',
' <%-=%-><%-:%-%*%-:%-><%*%-%-%*> METEORITES <%*%-%-%*><%-:%-%*%-:%-><%-=%-> ',
' <%-:%-><%-:%-%*%-:%-><%-%*%-> SUPERNOVAS <%-%*%-><%-:%-%*%-:%-><%-:%-> ',
}
function mob_name(name,line,wildcards)

    if string.find(line, "%!") ~= nil then
      temp= string.sub(line, 10, string.find(line, "%!")-1 )
    elseif string.find(line, "%.") then
      temp= string.sub(line, 10, string.find(line, "%.")-1 )
    end--if
    DebugNote (temp)
    for i,v in pairs(damage_verbs) do
      o, p =string.find(temp, v)  
      if p ~= nil then
        DebugNote (o.. " "..p.. " " .. v)
        DebugNote(temp)
        temp = string.sub(temp, p+1, #temp)
        last_Enemy = temp
        DebugNote(temp)
        return
      end--i
    end--for
    i = string.find(temp, "%A")
    while i  do 
      temp= string.sub(temp, i+1, #temp )
      i=string.find(temp, "[%A][%s]")
      DebugNote (i)
    end -- while
    temp= string.sub(temp, 2, #temp )
    last_Enemy= temp
end
function Add_To_Kill_Table(name, line, wildcards)
  if greedy == false then
    return
  end--if
  kill_info.room_id= currentRoom.roomid
  kill_info.name= last_Enemy
  Add_Kill_Table(kill_info)
end

function check_dead ()
  check_diff()
  for p, q in ipairs(room_num_table) do
    if cp_mobs[p].mobdead ~= nil then
      if  q[2] == cp_mobs[p].name and cp_mobs[p].mobdead == true  then --used to be k.name and k.mobdead in case it doesn't work
        room_num_table[p][3] = true
      else 
        room_num_table[p][3]= false       
      end--if 
    end     
  end--for
end
-- TODO: Evaluate if this function is actually needed anymore.
function check_diff()
  if AutoUpdate_var== true then
    return
  end--if
    for p, q in pairs(room_num_table) do
     
      if cp_mobs[p]== nil then
         --print (p)
        --tprint (q)
        delete_mob_from_table_index(p)
        return
      end--if 
      if string.lower(q[2])~= string.lower(cp_mobs[p].name) and #room_num_table > #cp_mobs  then 
       delete_mob_from_table_index(p) -- not sure if this is working yet
       DebugNote ("If you see this message this was the function causing the stack overflow")
       elseif string.lower(q[2])~= string.lower(cp_mobs[p].name) and #room_num_table < #cp_mobs then
      DebugNote('room <cp_mobs and names dont match')
        if myThread== nil  or coroutine.status (myThread) == "dead" then
          myThread = coroutine.create(buildRoomTable)
          AddTimer ("tickler", 0, 0, .1, "",
             timer_flag.Enabled + timer_flag.Replace,
             "tickle_it")
        end--if
        return
      end--if
      if string.lower(q[2])~= string.lower(cp_mobs[p].name) and #room_num_table == #cp_mobs then
       DebugNote('room ==cp_mobs and names dont match')
       DebugNote(q[2].. " ".. cp_mobs[p].name)
        if myThread== nil  or coroutine.status (myThread) == "dead" then
          myThread = coroutine.create(buildRoomTable)
          AddTimer ("tickler", 0, 0, .1, "",
             timer_flag.Enabled + timer_flag.Replace,
             "tickle_it")
          
        end--if
      end--if
    end--for  
  mob_index= 1
  var.cp_mobs = serialize.save( "cp_mobs", cp_mobs )
  phelper:broadcast(1, var.cp_mobs)
end

myThread= nil
local level = 0
local oldlevel = 0

function OnPluginBroadcast (msg, id, name, text)
    
    if (id == '3e7dedbe37e44942dd46d264') then
        if (text == "room.info") then
            res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
            luastmt = "gmcpdata = " .. gmcparg
            assert (loadstring (luastmt or "")) ()
            currentRoom = {
              name = gmcpdata.name,
              roomid = gmcpdata.num,
              areaid = gmcpdata.zone
            }
            started = true
            OnPluginInstall()
        end
        if (text == "char.status") then
            res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.status")
            luastmt = "gmcpdatacharstatus = " .. gmcparg
            assert (loadstring (luastmt or "")) ()
            char_status = gmcpdatacharstatus
            mylevel = tonumber(gmcpdatacharstatus.level)
            started = true
            
        end
        if (text == "char.base") then
            res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.base")
            luastmt = "gmcpdata = " .. gmcparg
            assert (loadstring (luastmt or "")) ()
            mytier = tonumber(gmcpdata.tier)
        end
        if mylevel ~= oldlevel and didonce == true then
            print('level != oldlevel')
            CpMobsAbr(level)
            oldlevel = mylevel
        end
        
        if (text == "char.base") then
            res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.base")
            luastmt = "gmcpdatacharstatus = " .. gmcparg
            assert (loadstring (luastmt or "")) ()
            char_base= gmcpdatacharstatus
        end
    end
end

CPMobsLevelBound = nil
-- takes a level and makes a CPmobs table that is within 30 level of our current level
function CpMobsAbr(str)
    print('building CPMobsLevelBound')
  CPMobsLevelBound = nil
  levelAdj= 30
  levmin = tonumber(str)-levelAdj
  levmax = tonumber(str)+levelAdj
  query = string.format("select *, count(*) as timeskilled from CPMobs "..
    " where level < %s and level > %s "..
    " group by room_id order by  name, timeskilled desc", levmax, levmin)

  c = 0
  CPMobsLevelBound = {}
  for rows in dbkt:nrows(query) do
    c = c+1
    CPMobsLevelBound[c] = {
    name = rows.name,
    room_id = rows.room_id,
    room_name = rows.room_name,
    area_name = rows.area_name,
    level = rows.level,
    timeskilled = rows.timeskilled
  }
  end
print('Finished building CPMobsLevelBound')
end

function tickle_it ()

  -- if background task exists, and is suspended, resume it
  if myThread ~= nil and
     coroutine.status (myThread) == "suspended" then
    coroutine.resume (myThread)
  else
    EnableTimer ("tickler", false)  -- don't need timer now
  end -- if
end -- tickle_it 

room_num_table = {}

function clearTable()
  room_num_table= {}
  room_num_table2= {}
end

function makeTable(room_num, name, bool, isInTable, area, num)-- stores all names and room numbers into a global table
  room_num_table[counter]= {room_num, name, bool, isInTable, area, tonumber(num)}
  counter= counter + 1
  

end
function makeTable2(room_num, name, bool, inTable, area)-- stores all names and room numbers into a global table
  room_num_table2[counter1]= {room_num, name, bool, inTable, area}
  counter1= counter1 + 1
  

end
--TODO: Change both prints to actually be something worth looking at.
function printTable() -- prints the global table for names and room numbers, used for debugging or quick checking
 if room_num_table ~= nil and #room_num_table>0 then
    ColourNote("Gray", "", "NUM  Mob name                             Dist   RoomId        Area")
    ColourNote("Gray", "", "------------------------------------------------------------------------");
    for i, row in pairs(cp_mobs) do
      print(string.format("%3d  %-35s  %-3s %-10s (%s) ", i, row.name,row.dist,room_num_table[i][1]  ,row.location))
    end
    ColourNote("Gray", "", "------------------------------------------------------------------------");
  DebugNote(cp_mobs)
  else
    print ("Nothing to print")
  end--if
end

function printTable1() -- prints the global table for names and room numbers, used for debugging or quick checking
 if room_num_table2 ~= nil and #room_num_table2>0 then
  tprint(room_num_table2)
  else
    print ("Nothing to print")
  end--if
end

curMob= ''
mobname= ''
word_count= tonumber(0)

function getTable(index) -- returns the first item in the table of room numbers, also makes a variable 'mobname' which is used for the autokill comand
    if room_num_table[index]== nil then
      return -1
    end
      local num =room_num_table[tonumber(index)][1]
      curMob= room_num_table[tonumber(index)][2]
    getName(index, 1)
    return num
end
-- Questioning why I am passing the num variable here... was this legacy?
function getName(index, num)
  local s= ''
  if cp_mobs== nil then
    print ("Use tcp before that command please")
    return
  end--if
  s = room_num_table[tonumber(index)][2] or curMob
 mobname = sanitizeName(s)
end

function sanitizeName(s)
local exit = 0
if s==nil then
  Note("s was nil")
  return
end
if check_CPMobs_Table()>0 then-- this needs to be reworked once all versions are unified. Aka when all versions have CPMobs support for Room CPs
  check_Keywords = string.format("SELECT keywords from CPMobs WHERE name= %s and keywords <> '';", fixsql(s)) 
  if dbkt:exec(check_Keywords) == 0 then
    DebugNote("Was not busy on database call")
    for keys in dbkt:nrows(check_Keywords) do
      DebugNote(keys)
      if keys.keywords ~= nil and keys.keywords ~= '' then
        mobname = keys.keywords
        exit = 1
      end
    end
  else
    DebugNote("The call in sanatize name to keywords was busy")
  end
  if exit == 1 then
    return mobname
  end
end
  local s2= {}
  s =string.gsub(s, "-", " ")
  s =string.gsub(s, "'", " ")
  s =string.gsub(s, "%@r", " ")
  for i in s:gmatch( "%a+") do
    word_count = tonumber(word_count) + 1
    s2[word_count]= i
    s2[word_count]= string.gsub(s2[word_count] , ",", " ")
  end -- for
  word_count= 0
  if (s2[1] == "a" or s2[1] == "A" or s2[1] == "An" or s2[1] == "the" or s2[1] == "The" or s2[1] == "an") and table.getn(s2) >1 then
    if table.getn(s2)>2
    then
      s2[2]= string.sub(s2[2], 0, 3)
      s2[3] = string.sub(s2[#s2],0, 3)
      mobname = s2[2].." "..s2[3]
      else
      mobname = s2[2] 
    end -- if
  else
  if table.getn(s2)>1
  then
    s2[1]= string.sub(s2[1], 0, 3)
    s2[2] = string.sub(s2[#s2],0, 3)
    mobname = s2[1].." "..s2[2]
  else
    mobname = s2[1]
  end--if
  end--if
    return mobname
end  
    
function buildRoomTable()-- This sends the table to get room_ids
--local time1 = socket.gettime()*1000
  if cp_mobs ==nil then
      cp_mobs = mobsleft
  end
  counter = tonumber(1)
  counter1 = tonumber(1)
  FirstRun_cp_var = false
  clearTable()
  local roomCPCheck = 0
  for i,v in ipairs (cp_mobs) do
    roomCPCheck = getRoomId(cp_mobs[i].name, i )
    -- if (i%3== 0)then
    --   coroutine.yield(myThread)
    -- end--if
  end
    coroutine.yield(myThread)
  for i,v in ipairs(room_num_table) do
    if (room_num_table[i][4]== false) then
      cp_mobs[i].intable = false
    else
      cp_mobs[i].intable = true
    end--if
  end --for
  DebugNote('==============================')
  sortRoomCPByPath()
  var.cp_mobs = serialize.save( "cp_mobs", cp_mobs )
  phelper:broadcast(1, var.cp_mobs)
end

local shortaname 

function getRoomId(name, tableNum)-- Gets a roomId from campaign
local loc = cp_mobs[tableNum].location
dbA=sqlite3.open(GetInfo (66) ..'Aardwolf.db')
  if dbA:isopen() then
    local query1 = "select rooms.uid as room, rooms.name as roomName, rooms.area as area, areas.name as areaName, 'room' as type "..
        " from rooms rooms, areas "..
        " where areas.uid = rooms.area and "..
        " rooms.name = %s "..
        " union "..
        " SELECT rooms.uid as room, rooms.name as roomName, areas.uid as area, areas.name as areaName, 'area' as type" ..
        " FROM areas, rooms " ..
        " WHERE areas.name = %s and "..
        "rooms.area = areas.uid "..
        " ORDER BY type ASC "
    sql_now= string.format(query1, fixsql(loc), fixsql(loc) )
    local count_check= 0
    local hld = {}
    for rows in dbA:nrows(sql_now) do
     
      table.insert(hld, rows)
    end -- for
    for g, rows in pairs(hld) do
      -- this whole thing needs reworked... its a mess right now..
      if rows.type== 'room' then
        getRoomIdRoomCP(name,name, tableNum)
        dbA:close()
        return 1
      else
        getRoomIdAreaCP(name, tableNum)
        dbA:close()
        return 0
      end--if
    end 
  end--if
end
sublist={1,1}
--TODO: Evaluate if this needs to be here at all.
function testtime(name)
 
end

function getRoomIdAreaCP(name, tableNum)
    local nameHolder= nil
    local roomNumber= nil
    local roomTemp= nil
    local loc = cp_mobs[tableNum].location
    local dbKillT = dbkt --dbkt assigner
    local found = false
    local time1 = socket.gettime()
    local thisrooms = rooms
    local thisareas = areas
    local timeskilled = 0
    local  cpmobquery = string.format("select room_id, area_name, name, COUNT(*) as timeskilled "..
        "from CPMobs "..
        "where name like %s and "..
        "area_name = %s "..
        "group by room_id, name "..
        "ORDER by timeskilled desc ", fixsql(name), fixsql(loc))
    if CPMobsLevelBound ~= nil then
        for i, p in pairs(CPMobsLevelBound) do
            if name == p.name and loc == p.area_name and timeskilled<p.timeskilled then 
              nameHolder = name
              roomNumber = p.room_id
              timeskilled = p.timeskilled
              found = true
            end
        end
    end
    if found == false then
        DebugNote("in query block")
        for a in dbKillT:nrows(cpmobquery) do
         DebugNote(a)
            if found== false then
                DebugNote('the one I will use is: ')
                DebugNote (a)
                nameHolder = a.name
                roomNumber = a.room_id
                found = true
            end
        end   
    end
    local count= 0
    if found == false then 
        testtime(name)-- this gets called every mob in your cp list let me show you the flow
        sublist={}
        for i, p in pairs(mobktbl) do
            if p.name == name then 
                table.insert(sublist, {p.name, p.room_id, p.timeskilled})
            end
        end
      DebugNote("\n In second block ".. name.."\n")
        for i,a in pairs(sublist) do
            count = count+1 
            DebugNote(a)
            DebugNote("-----")
            nameHolder=a[1]
            roomTemp= tostring(a[2])
                if found == false then
                    if thisrooms[roomTemp] ~= nil then  
                        if loc == thisareas[thisrooms[roomTemp].area].name and found == false then
                            DebugNote(a[1])
                            found = true
                            roomNumber = roomTemp
                        end
                        DebugNote("+++++")
                    end
                end
        end --for
    end --if
    if roomNumber ~= nil and nameHolder ~=nil then
        DebugNote ("check")
        --tprint (cp_mobs)
        DebugNote(cp_mobs[tableNum].num)
        DebugNote ("///check")
        makeTable(tonumber(roomNumber), nameHolder, cp_mobs[tableNum].mobdead, true, loc, cp_mobs[tableNum].num)
        mob_index= 1
    end--if
    if roomNumber == nil then
        DebugNote("here")
        makeTable(loc, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, false, loc, cp_mobs[tableNum].num)
        mob_index= 1
    end--if
end

function getRoomIdRoomCP(name, nameHolder, tableNum)-- TODO some bug here where it drops the last 2 things in list
    local loc = cp_mobs[tableNum].location
    local mob_table_name= ''
    local rows_counter= 1
    local rows_counter_check= 0
    local databasetest = dbA
    local databasekt = dbkt --dbkt assigner
    local make1 = makeTable
    local make2 = makeTable2
    local call = CallPlugin
    local DebugNote = DebugNote
    local findmob_table= {}
    local area_table= {}
    local strbld = string.format
    local room_num_table= room_num_table
    local room_num_table2= room_num_table2
    local tableNum = tonumber(tableNum)
    local levelAdj = 11
    local found = 0
    local areaName

    res, gmcparg = call("3e7dedbe37e44942dd46d264","gmcpval","char") --- We just want the gmcp.char section.
    luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.
    assert (loadstring (luastmt or "")) ()
    level = tonumber(gmcpdata.status.level) -- uncomment for live
    if GQ_flag then levelAdj = 22 end
    --level = 70 -- for testing
    min_level = level - levelAdj 
    max_level = level + levelAdj

    if (min_level<0)then min_level=0 end
        local queryCount = strbld("select COUNT(*) as counter"..
          " from rooms, areas"..
          " where areas.uid = rooms.area and rooms.name = %s",fixsql(cp_mobs[tableNum].location))
        local query1 = strbld("select rooms.uid as roomuid,"..
          " areas.name as areaName,"..
          " rooms.name as roomName"..
          " from rooms rooms, areas"..
          " where areas.uid = rooms.area and rooms.name = %s",fixsql(cp_mobs[tableNum].location))
        local  cpmobquery = string.format("select room_id, area_name, name, COUNT(*) as timeskilled "..
            "from CPMobs "..
            "where name like %s and "..
            "room_name = %s"..
            "group by room_id, name "..
            "ORDER by timeskilled asc ", fixsql(name), fixsql(loc))
        
        for rows in databasekt:nrows(cpmobquery) do
            roomNumber = rows.room_id
            areaName = rows.area_name
            found = 1
        end
        if found == 1 then 
            found = 0
            DebugNote("found it in the cp_mobs table 001")
            make1(roomNumber, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, true, areaName, cp_mobs[tableNum].num)
            return
        end
        for rows in databasetest:nrows(queryCount) do
            rows_counter = rows.counter
        end--for
        for rows in databasetest:nrows(query1) do        
            rows_counter_check = rows_counter_check+1
            area_table[rows_counter_check] = rows
        end--for
        local area_table_size = #area_table
        for z=1, area_table_size do  
            roomNumber= tonumber(area_table[z].roomuid)
            if areaLevel[area_table[z].areaName].minLevel > max_level or areaLevel[area_table[z].areaName].maxLevel<min_level then -------- testing with and was or
                rows_counter= rows_counter-1
                rows_counter_check = rows_counter_check-1
            else
                local foundone_room_table2 = false
                local foundone_room_table = false
                if room_num_table ~= nil and #room_num_table >0 then
                   for p= 1, #room_num_table do
                       if (string.lower(room_num_table[p][2]) == string.lower(nameHolder) or room_num_table[p][1]== area_table[z].uid)
                        and tableNum== tableNumHolder then foundone_room_table= true  end--if-- cp_mobs[tableNum].name
                    end--for
                end--if
                if #room_num_table2 > 0 and room_num_table2 ~= nil then
                    for i= 1, #room_num_table2 do
                        if area_table[z].areaName == room_num_table2[i][5] or room_num_table2[i][1]== area_table[z].roomuid  then-- see if the first condition needs and tableNum == tableNumHolder
                 
                            foundone_room_table2 = true
                            break
                        else
                            foundone_room_table2 = false
                        end--if
                    end--for
                end--if
                if not foundone_room_table then
                    make1(roomNumber, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, true, area_table[z].areaName, cp_mobs[tableNum].num)
                    tableNumHolder= tonumber(tableNum)
                    mob_index= 1
                elseif not foundone_room_table2 then
                    make2(roomNumber, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, true, area_table[z].areaName, cp_mobs[tableNum].num)
                    mob_index= 1
                end--if
        end--for
    end--if
    tableNumHolder= tonumber(tableNum)
    mob_index= 1
end
room_not_in_database = {}
-- This section is almost a straight rip from Fiendish's aard_GMCP_mapper.xml all credit goes to him
local bit = require("bit")
function load_room_from_database (uid)
   local room
   local u = tostring(uid)
   assert (uid, "No UID supplied to load_room_from_database")

   -- if not in database, don't look again
   if room_not_in_database [u] then
      return nil
   end -- no point looking
-- print('here?')
   for row in dbnrowsWRAPPER(string.format ("SELECT * FROM rooms WHERE uid = %s", fixsql (u))) do
      room = {
         name = row.name,
         area = row.area,
         building = row.building,
         terrain = row.terrain,
         info = row.info,
         notes = row.notes,
         x = row.x or 0,
         y = row.y or 0,
         z = row.z or 0,
         noportal = row.noportal,
         norecall = row.norecall,
         exits = {},
         exit_locks = {},
         ignore_exits_mismatch = (row.ignore_exits_mismatch == 1)
      }

      for exitrow in dbnrowsWRAPPER(string.format ("SELECT * FROM exits WHERE fromuid = %s", fixsql (u))) do
         room.exits [exitrow.dir] = tostring (exitrow.touid)
         room.exit_locks [exitrow.dir] = tostring(exitrow.level)
      end -- for each exit
   end   -- finding room
   if room then
      if not rooms then
         -- this shouldn't even be possible. what the hell.
         rooms = {}
      end
      rooms [u] = room
      for row in dbnrowsWRAPPER(string.format ("SELECT * FROM bookmarks WHERE uid = %s", fixsql (u))) do
         rooms [u].notes = row.notes
      end   -- finding room
      --tprint(room)
      return room
   end -- if found

   -- room not found in database
   room_not_in_database [u] = true
   return nil

end -- load_room_from_database
forced_opened = false
force_nests = 0
function sanitize_filename(str)
   str = string.gsub(str, "[^%w%s()_-]", "")
   return Trim(str)
end
worldPath = GetInfo(66)..sanitize_filename(WorldName())
db = assert (sqlite3.open(worldPath..".db"))
db:busy_timeout(100)
function forceOpenDB()
   force_nests = force_nests+1
   if not db:isopen() then
      forced_opened = true
      -- print("Forcing open")
      db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
   end
end
function dbnrowsWRAPPER(query)
   forceOpenDB()
   iter,vm,i = db:nrows(query)
   local function itwrap(vm, i)
      retval = iter(vm, i)
      if not retval then
         closeDBifForcedOpen()
         return nil
      end
      return retval
   end
   return itwrap,vm,i
end
function closeDBifForcedOpen()
   force_nests = force_nests-1
   if forced_opened and (force_nests <= 0) then
      force_nests = 0
      forced_opened = false
      db:close()
   end
end
function findNearestJumpRoom(src, dst, target_type)
   local depth = 0
   local max_depth = 500
   local room_sets = {}
   local rooms_list = {}
   local found = false
   local ftd = {}
   local destination = ""
   local next_room = 0
   local visited = ""
   local path_type = ""

   table.insert(rooms_list, fixsql(src))
   while not found and depth < max_depth do
      depth = depth + 1

      -- prune the search space
      if visited ~= "" then
         visited = visited..","..table.concat(rooms_list, ",")
      else
         visited = table.concat(rooms_list, ",")
      end

      -- get all exits to any room in the previous set
      local q = string.format ("select fromuid, touid, dir, norecall, noportal from exits,rooms where rooms.uid = exits.touid and exits.fromuid in (%s) and exits.touid not in (%s) and exits.level <= %s order by length(exits.dir) asc",
                  table.concat(rooms_list,","), visited, mylevel)
      local dcount = 0
      for row in dbnrowsWRAPPER(q) do
         dcount = dcount + 1
         table.insert(rooms_list, fixsql(row.touid))
         -- ordering by length(dir) ensures that custom exits (always longer than 1 char) get
         -- used preferentially to normal ones (1 char)
         if ((bounce_portal ~= nil or target_type == "*") and row.noportal ~= 1) or ((bounce_recall ~= nil or target_type == "**") and row.norecall ~= 1) or row.touid == dst then
            path_type = ((row.touid == dst) and 1) or ( (((row.noportal == 1) and 2) or 0) + (((row.norecall == 1) and 4) or 0) )
            -- path_type 1 means walking to the destination is closer than bouncing
            -- path_type 2 means the bounce room allows recalling but not portalling
            -- path_type 4 means the bounce room allows portalling but not recalling
            -- path_type 0 means the bounce room allows both portalling and recalling
            destination = row.touid
            found = true
            found_depth = depth
         end -- if src
      end -- for select

      if dcount == 0 then
         return -- there is no path to a portalable or recallable room
      end -- if dcount
   end -- while

   if found == false then
      return
   end
   return destination, path_type, found_depth
end
function findpath(src, dst, noportals, norecalls)
  local rooms = {}
   DebugNote('source room is : '..src)
   DebugNote('destination room is : '..dst)
   if not rooms[src] or src == '-1' then
      if src == "-1" then
        src = "nomap_"..currentRoom.name.."_"..currentRoom.areaid
      end
      rooms[src] = load_room_from_database(src)
   end
   if not rooms[src] then
      return
   end
   if tostring(src) == tostring(dst) then
    return {},0 
    end
   local walk_one = nil
   for dir,touid in pairs(rooms[src].exits) do
      if tostring(touid) == tostring(dst) and tonumber(rooms[src].exit_locks[dir]) <= mylevel and ((walk_one == nil) or (#dir > #walk_one)) then
         walk_one = dir -- if one room away, walk there (don't portal), but prefer a cexit
      end
   end
      if walk_one ~= nil then
      return {{dir=walk_one, uid=touid}}, 1
   end
   local depth = 0
   local max_depth = 500
   local room_sets = {}
   local rooms_list = {}
   local found = false
   local ftd = {}
   local f = ""
   local next_room = 0 
   if type(src) ~= "number" then
      src = string.match(src, "^(nomap_.+)$") or tonumber(src)
   end
   if type(dst) ~= "number" then
      dst = string.match(dst, "^(nomap_.+)$") or tonumber(dst)
   end

   if src == dst or src == nil or dst == nil then
      return {}
   end

   src = tostring(src)
   dst = tostring(dst)

   table.insert(rooms_list, fixsql(dst))

   local visited = ""
   while not found and depth < max_depth do
      depth = depth + 1
      if depth > 1 then
         ftd = room_sets[depth-1] or {}
         rooms_list = {}
         for k,v in pairs(ftd) do
            table.insert(rooms_list, fixsql(v.fromuid))
         end -- for from, to, dir
      end -- if depth

      -- prune the search space
      if visited ~= "" then
         visited = visited..","..table.concat(rooms_list, ",")
      else
         if noportals then
            visited = visited..fixsql("*")..","
         end
         if norecalls then
            visited = visited..fixsql("**")..","
         end
         visited = visited..table.concat(rooms_list, ",")
      end
      
      -- get all exits to any room in the previous set
      local q = string.format ("select fromuid, touid, dir from exits where touid in (%s) and fromuid not in (%s) and ((fromuid not in ('*','**') and level <= %s) or (fromuid in ('*','**') and level <= %s)) order by length(dir) asc",table.concat(rooms_list,","), visited,mylevel,mylevel+(mytier*10))
      local dcount = 0
      room_sets[depth] = {}
      for row in dbnrowsWRAPPER(q) do
       -- print('database was open')
         dcount = dcount + 1
         -- ordering by length(dir) ensures that custom exits (always longer than 1 char) get
         -- used preferentially to normal ones (1 char)
         room_sets[depth][row.fromuid] = {fromuid=row.fromuid, touid=row.touid, dir=row.dir}
         if row.fromuid == "*" or (row.fromuid == "**" and f ~= "*" and f ~= src) or row.fromuid == src then
            f = row.fromuid
            found = true
            found_depth = depth
         end -- if src
      end -- for select

      if dcount == 0 then
         return -- there is no path from here to there
      end -- if dcount
   end -- while

   if found == false then
      return
   end

   -- We've gotten back to the starting room from our destination. Now reconstruct the path.
   local path = {}
   -- set ftd to the first from,to,dir set where from was either our start room or * or **
   ftd = room_sets[found_depth][f]

   if (f == "*" and rooms[src].noportal == 1) or (f == "**" and rooms[src].norecall == 1) then
      if rooms[src].norecall ~= 1 and bounce_recall ~= nil then
         table.insert(path, bounce_recall)
         if dst == bounce_recall.uid then
            return path, found_depth
         end
      elseif rooms[src].noportal ~= 1 and bounce_portal ~= nil then
         table.insert(path, bounce_portal)
         if dst == bounce_portal.uid then
            return path, found_depth
         end
      else
         local jump_room, path_type = findNearestJumpRoom(src, dst, f)
         if not jump_room then
            return
         end
         local path, first_depth = findpath(src,jump_room, true, true) -- this could be optimized away by building the path in findNearestJumpRoom, but the gain would be negligible
         if bit.band(path_type, 1) ~= 0 then
            -- path_type 1 means just walk to the destination
            return path, first_depth
         else
            local second_path, second_depth = findpath(jump_room, dst)
            for i,v in ipairs(second_path) do
               table.insert(path, v) -- bug on this line if path is nil?
            end
            return path, first_depth+second_depth
         end
      end
   end

   table.insert(path, {dir=ftd.dir, uid=ftd.touid})

   next_room = ftd.touid
   while depth > 1 do
      depth = depth - 1
      ftd = room_sets[depth][next_room]
      next_room = ftd.touid
-- this caching is probably not noticeably useful, so disable it for now
--      if not rooms[ftd.touid] then -- if not in memory yet, get it
--         rooms[ftd.touid] = load_room_from_database (ftd.touid)
--      end
      table.insert(path, {dir=ftd.dir, uid=ftd.touid})
   end -- while
   return path, found_depth
end -- function findpath
-- end section of Fienish's work

function sortRoomCPByPath()
  local x
  local room = -1
  dist_tbl = {}
  DebugNote('==============================')
  DebugNote(currentRoom.roomid)
  for i, p in ipairs(room_num_table) do
    DebugNote(i)
    DebugNote(p)    
    x, dep = findpath(currentRoom.roomid,p[1])
    DebugNote('Depth:')
    DebugNote (dep)
    if dep ~= nil then
      table.insert(dist_tbl, { i, dep })
    else 
      table.insert(dist_tbl, {i, 501})
    end--if
  end
  local keys = {}
  local b = {}
  local q = {}
  for k in pairs(dist_tbl) do table.insert(keys, k) end
  DebugNote('keys')
  DebugNote(keys)
  table.sort(keys, function(a, b) return dist_tbl[a][2] < dist_tbl[b][2] end)
  for _, k in ipairs(keys) do 
    DebugNote('_ then k')
    DebugNote(_)
    DebugNote(k)
    DebugNote(k) 
    DebugNote(dist_tbl[k][1])
    DebugNote(dist_tbl[k][2])
    cp_mobs[k].dist = dist_tbl[k][2]
    table.insert(b, cp_mobs[k])
    table.insert(q, room_num_table[k])
  end
  room_num_table = q
  cp_mobs = b
  
end

mob_index= tonumber(1)
mob_next_delete_value= nil

function do_Execute_no_echo(command)
  local original_echo_setting = GetOption("display_my_input")
  SetOption("display_my_input", 0)
  Execute(command)
  SetOption("display_my_input", original_echo_setting)
end

function gotoNextMob()-- This will goto the next mob, use with tcp
  if cp_mobs == nil then
    print ('Nothing to go to!')
    return 
  end
  if mob_index == nil then
    mob_index=1
  end--if
  if room_num_table == nil or #room_num_table<1 then
    return
  end--if
  if room_num_table[1][1] == -1 then
    print ("Try tcpo or manually finding this mob.. use pto to check the other table")
    return
  end--if
  check_dead()
  if room_num_table[1][3] == false then
    if hunt_type(0, 0) == 1 then
      return
    end--if
 
    Execute('xmapper1 move '..  getTable(mob_index))
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(mob_index)
    mob_next_delete_value= mob_index
    Send("sca ".. mobname)
  else
    if hunt_type(0, 1) == 1 then
      return
    end--if
    Execute('xmapper1 move '..  getTable(mob_index+1))
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(mob_index+1)
    mob_next_delete_value= mob_index+1
    Send("sca ".. mobname)
  end--if
end

function gotoIndexMob(name, line, wildcards)-- This will goto the next mob, use with tcp
 
  wild= tonumber(wildcards[1])
  if wild == nil then return end
  if cp_mobs == nil then
    print("Nothing to goto.")
    return 
  end
  if tonumber(wildcards[1])<0 or tonumber(wildcards[1])> #room_num_table then
    return
  end
  if room_num_table == nil then
    return
  end--if
    if room_num_table[wild][1] == -1 then
    print ("Try tcpo or manually finding this mob.. use pto to check the other table")
    return
  end--if
  check_diff()
  check_dead()
    if hunt_type(wild, 0) == 1 then
      return
    end--if
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(wild)
    mob_next_delete_value= wild
    Execute('xmapper1 move '..  getTable(tonumber(wildcards[1])))
    Send("sca ".. mobname)
end

function tcpohandler(name, line, wildcards)
  if wildcards[1] ~= nil then
    if room_num_table2 == nil or tonumber(wildcards[1])>#room_num_table2 then
     return
    end--if
  end--if

  if #wildcards>=1 then
     mobname = sanitizeName(room_num_table2[tonumber(wildcards[1])][2])
    Execute ('xmapper1 move '.. room_num_table2[tonumber(wildcards[1])][1])
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(wildcards[1])
    mob_next_delete_value= wildcards[1]
    Send("sca ".. mobname)
  else
    mobname = sanitizeName(room_num_table2[1][2])
    Execute ('xmapper1 move '.. room_num_table2[1][1])
    mob_next_delete_value= 1
    Send("sca ".. mobname)
  end--if
end

function hunt_type (num, mob_id)
  if mob_index == 0 then
    local mob_index = 1
  else
    local mob_index = 2
  end--if
  if num ~= 0 then
    if type(room_num_table[tonumber(num)][1])== 'string' then -- If An index query and room type
      DebugNote("Entry for mob_next_delete_value")
    DebugNote(num)
      mob_next_delete_value= tonumber(num)
      holder= getTable(num)  
      if ((string.find(string.lower(room_num_table[num][1]), currentRoom.areaid))) then
        print('well this is awkward you are already in the correct area')
      else
        Execute('xrunto1 '..room_num_table[num][1])
      end--if
      cpn_script(tonumber(num))
      
      return 1
    end--if
  else
    if type(room_num_table[mob_index][1])== 'string' then-- if NOT an indexed query and a room type
      DebugNote("Entry for mob_next_delete_value")
    DebugNote(mob_index)
    mob_next_delete_value= mob_index
    holder= getTable(mob_index)
    if (( string.find(string.lower(room_num_table[mob_index][1]), currentRoom.areaid))) then
      print('well this is awkward you are in the correct area')
    else
      Execute('xrunto1 '..room_num_table[mob_index][1])
    end--if
    cpn_script(mob_index)
      
      return 1      
    end--if
  end--if
end

where_mob= ''

function whereMob(name, line, wildcards)
  where_mob= wildcards[1]
  if where_mob==nil then
     if mobname ~= nil then
      EnableTrigger('where_mob_trig', true)
      Execute('where '.. mobname)

      DoAfterSpecial(2, "EnableTrigger('where_mob_trig', false)", 12)
    else
      print ("Need to use tcp or tcp <index> first")
      return
    end --if
  else
    EnableTrigger('where_mob_trig', true)
    Execute('where '.. where_mob)
    DoAfterSpecial(1, "EnableTrigger('where_mob_trig', false)", 12)
    where_mob = string.gsub(where_mob,"%d+%.","")
    mobname =  where_mob
  end--if
end

local where_black_list = {"Your magic is blessed with",
"You feel less righteous as the",
"You now possess magical powers",
"You feel gills growing on your",
"You now detect the presence of"}
function where_mob_trig(name, line, wildcards)
  for i,p in ipairs(where_black_list) do
    if (string.find( wildcards[0], p) ~= nil) then
      return
    end--if
  end--for
    wildcards[1], x = string.gsub(wildcards[1],"%.","")
  bool = 0
  for word in mobname:gmatch("%w+") do
  if (string.find( string.lower(wildcards[1]), string.lower(word)) ~= nil) then 
    bool =1
  end--if

  end -- for
  if bool == 1 then
    Execute('mapper area '.. '"'..wildcards[2]..'"')
    Execute('mapper next')
    EnableTrigger('where_mob_trig', false)
  end--if
end

function killMob()
  if mobname ~= nil then
    Execute("kill ".. mobname)
  else
    print ("Need to use aknx or aknx <index> first")
  end --if
end

function fixsql (s)
   if s then
      return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
   else
      return "NULL"
   end -- if
end -- fixsql

areaLevel= {}

-- In case of a mob not in the db then these will get used

count = 1
function incrementCounter()
count = count + 1
Execute("hunt ".. count..".".. mobname)
end

function reset_counter()
 count=1
end
CPMobs= {}
CPMobs1= {}
CPMobsIndex= 1
vnum_holder= 0
function reset_index()
 CPMobsIndex = 1
 CPMobs1= {}
end

cpn_is_room_type= false
cpn_is_room_type_table = {}
cpnrtt = 1



function hunt_from_link( area)
  DebugNote (area)
  Execute("xrunto1 ".. area)
  Execute ("hunt " .. mobname)
end

dbA= nil
dbkt= nil
rooms = {1, 1}
areas = {}
mobktbl = {}
function StartScript()
  print("here")
  do_Execute_no_echo('map')

  do_Execute_no_echo("cp check")
  

  db=sqlite3.open(GetInfo (66) ..'\\logs\\aardinfo.db')
  query= "select keyword, name, afrom, ato, alock from areas"
  rc =db:exec(query)
  if rc ~= 0 then 
    db:close()
    os.remove(GetInfo (66) .."\\logs\\aardinfo.db")
    os.rename(GetPluginInfo (GetPluginID (), 20) .."aardinfo.db", GetInfo (66) .."\\logs\\aardinfo.db")
    db=sqlite3.open(GetInfo (66) ..'\\logs\\aardinfo.db')
    
  end
  local v =tonumber(0)
  for a in db:nrows(query) do
    areaLevel[a.name]= {}
    areaLevel[a.name].keyword= a.keyword
    areaLevel[a.name].name = a.name
    areaLevel[a.name].minLevel= a.afrom
    areaLevel[a.name].maxLevel= a.ato
    areaLevel[a.name].lock = a.alock or ''
    v = v +1
  end-- for
  v = 0
  db:close()
  dbA=sqlite3.open(GetInfo (66) ..'Aardwolf.db')
  print (GetPluginInfo (GetPluginID (), 20))
  dbkt=sqlite3.open(GetPluginInfo (GetPluginID (), 20) .. 'KillTable.db')
  dbkt:busy_handler(myHandler)
  qry= "select * from rooms where uid not like '*' and uid not like '**' order by uid"
  qry2 = "select * from areas"
  qry3 = "select *, count(*) as timeskilled from mobkills group by room_id order by name, timeskilled desc"
  c= 0
  CpMobsAbr(mylevel)
  rooms = {}
  
  for row in dbA:nrows(qry) do
    
    rooms[row.uid]= {} 
      c = c+1
    
    rooms[row.uid] = {
    name = row.name,
    area = row.area,
    terrain = row.terrain,
    info = row.info,
     noportal = row.noportal,
     norecall = row.norecall,
     ignore_exits_mismatch = (row.ignore_exits_mismatch == 1),
     exits = {},
     exit_locks = {}
    }
  
  end
  for row in dbA:nrows(qry2) do
    areas[row.uid] = {
      name = row.name
  }
  end
 -- c = 0
  for row in dbkt:nrows(qry3) do
   c = c+1
    mobktbl[c] = {
      name = row.name,
      room_id =row.room_id,
      timeskilled = row.timeskilled
  }
  end -- end of for loop? lol, whoops ok  lets do it
      for i,v in pairs(rooms) do
        c =c +1
      end
  rc =dbkt:exec([[SELECT name, room_id FROM mobkills ]])
  if rc~= 0 then
    init()
    print ('making table')
  end--if
  if not IsPluginInstalled("0961770926b613688a1c5458") then
    LoadPlugin(GetPluginInfo (GetPluginID (), 20) .. "cp_mobTableFiller.xml")
  end
  if not IsPluginInstalled("eee3a98a021c1bee534ef09f") then
    LoadPlugin(GetPluginInfo (GetPluginID (), 20) .. "TOLminwin.xml")
  end
  dbA:close()
end
local didonce = false

function OnPluginInstall()
    if IsConnected() and started == true and didonce == false then
        res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
            luastmt = "gmcpdata1 = " .. gmcparg
            
            assert (loadstring (luastmt or ""))
						if gmcpdata1 ~= nil then -- fix attempt - Kobus
						currentRoom = {
							name = gmcpdata1.name,
							roomid = gmcpdata1.num,
							areaid = gmcpdata1.zone
            }
        res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.status")
            luastmt = "gmcpdatacharstatus = " .. gmcparg
            assert (loadstring (luastmt or ""))
            char_status = gmcpdatacharstatus
            mylevel = tonumber(gmcpdatacharstatus.level)
        res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.base")
            luastmt = "gmcpdata = " .. gmcparg
            assert (loadstring (luastmt or ""))
            mytier = tonumber(gmcpdata.tier)
        res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.base")
            luastmt = "gmcpdatacharstatus = " .. gmcparg
            assert (loadstring (luastmt or ""))
            char_base= gmcpdatacharstatus
				end -- fix attempt - Kobus
        StartScript()
        print("start")
        didonce = true
        started = true
    end
end
function myHandler(udata, retries)
   DebugNote("BUSY!")
   return true
end
function OnPluginClose ()
    --dbA:close()
    if dbkt ~= nil and dbkt:isopen() then dbkt:close() end
end

function reset_cp_flag( )
  timeEnd()
  FirstRun_cp_var= true
end

function collectgarbagenow()
 --Note( collectgarbage("count")*1024)
  collectgarbage("collect")
  --Note( collectgarbage("count")*1024)
end

function DebugNote( msg )
  if not Debug then return end
    if type(msg)== 'table' then
      tprint(msg)
    else
      Note (msg)
    end
  
end
-- This whole block is ripped directly from Winkle's plugin, all credit to him.
---//////////////////////////////////////////////////////////////////////////////////////////////////
--////////////////                                    |\     |          ^
--///////////////                                     | \    |        /   \
--//////////////                                      |  \   |       /     \
--/////////////                                       |   \  |      <       >
--////////////                                        |    \ |       \     /
--///////////                                         |     \|        \   /
--//////////                                          |      |          v
--///////////////////////////////////////////////////////////////////////////////////////////////////
local xrun_to_sql1 =  
    "SELECT r.uid, r.name as room, a.name as area " ..
    "FROM rooms r " ..
    "INNER JOIN areas a ON a.uid = r.area " ..
    "WHERE a.uid like %s " ..
    "ORDER BY r.uid "
    
  local xrun_to_sql2 =  
    "SELECT r.uid, r.name as room, a.name as area " ..
    "FROM rooms r " ..
    "INNER JOIN areas a ON a.uid = r.area " ..
    "WHERE a.uid like %s " ..
    "OR a.name like %s " ..
    "ORDER BY r.uid "

    local xrun_to_sql_FR = 
      " SELECT b.uid, b.notes "..
      " FROM bookmarks b "..
      " INNER JOIN rooms r on r.uid = b.uid "..
      " WHERE r.area like %s " ..
      " AND b.notes = 'Tstart' "

  function xrun_to1(name, line, wildcards)
    local index1 = 1
    local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
    local db = assert(sqlite3.open(worldPath .. ".db"))
    db:busy_handler(myHandler)

    -- HACK for ftii
    if (wildcards[1] == "ft2") then
      wildcards[1] = "ftii"
    end
    local like = fixsql("%" .. wildcards[1] .. "%")
    -- try exact hit first
    local select1 = string.format (xrun_to_sql1, fixsql(wildcards[1]))
    DebugNote("xrun_to (1)- " .. select1)
    local select2 = string.format (xrun_to_sql_FR, like)
    DebugNote("xrun_to (1)- " .. select2)
    for row in db:nrows(select2) do 
      DebugNote(row)
      goto_roomid(row.uid)
      index1 = index1 +1
      db:close()
      return
    end
    
    --Note(string.format (sql, fixsql(wildcards[1])))
    for row in db:nrows(select1) do

      ColourNote("darkorange", "", "x-runto (" .. row.uid .. ") " .. row.room .. " in " .. row.area)
      goto_roomid(row.uid)
      
      index1 = index1 + 1
      db:close()
      return
    end
    

    
    select1 = string.format (xrun_to_sql2, like, like)
    DebugNote("xrun_to (2)- " .. select1)

    for row in db:nrows(select1) do
      ColourNote("darkorange", "", "x-runto (" .. row.uid .. ") " .. row.room .. " in " .. row.area)
      goto_roomid(row.uid)
      
      index1 = index1 + 1
      db:close()
      return
    end

    if (index1 == 1) then

      ColourNote("darkorange", "", "No matching rooms found. Using aardwolf runto...")
      Execute("xmapper1 move 32418") -- recall
      Execute("runto " .. wildcards[1])
    end
    db:close()
  end

  function goto_roomid(roomid)
      Execute("xmapper1 move " .. roomid)
  end
  local execute_in_area_array = {}

  function execute_in_area(id, areaId, functionPointer)

    execute_in_area_array[id] = { 
      areaId = areaId, 
      func = functionPointer, 
      index = 0, 
      active = true,
      lastState = 3, -- standing
      standIndex = 0 -- count of stands in a row
      }
    EnableTimer("execute_in_area_timer", true)

  end

  function execute_in_area_tick(name, line, wildcards)
    local localRoom = currentRoom
    local localState
    if (localRoom == nil) then
      return
    end
    
    if (char_status == nill) then
      return
    else
      localState = tonumber(char_status.state)
    end

    local isActive = false
    for index, value in pairs(execute_in_area_array) do
      if (value.active == true) then
    
        value.index = value.index + 1

        if (value.index > 100) then
          value.active = false
          print("** aborting quickwhere timer for " .. index1 .. ", took too long to get to destination")
          
        else


          if ((localState == 3 and value.lastState == 3) 
            and value.areaId == localRoom.areaid) then

            -- skip first timer tick
            value.index = value.index + 1
            value.standIndex = value.standIndex + 1
            if (value.standIndex < 2) then
            else
              value.func()
              value.active = false            
            end
          else
            -- still moving.. reset index
            value.standIndex = 0
          end
        end
      end
      
      value.lastState = localState
      
      if (value.active == true) then
        isActive = true
      end
      
    end
    
    -- no timer items active.. disable
    if (isActive == false) then
      --DebugNote("disable timer")
      EnableTimer("execute_in_area_timer", false)
    end
  end

  local speed = "run"
    function move_trigger(name, line, wildcards)
    
    if (wildcards.roomid ~= "") then
      move(wildcards.roomid, wildcards.speed)
    end
    
  end
  
  function move(roomid, temp_speed)
  
    if (temp_speed == nil or temp_speed == "") then
      temp_speed = speed
    end
    if (temp_speed == "walk") then
      Note("walking to " .. roomid)
      Execute("mapper walkto " .. roomid)
    else
      Execute("mapper goto " .. roomid)
    end
  end
  function sanitize_filename(str)
    str = string.gsub(str, "[^%w%s()_-]", "")
    return str
  end

]]>
</script>


</muclient>
