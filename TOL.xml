<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, May 21, 2015, 8:46 AM -->
<!-- MuClient version 4.79 -->

<!-- Plugin "TOL" generated by Plugin Wizard -->

<muclient>
<plugin
   name="TOL"
   author="Sonet"
   id="8065ca1ba19b529aee53ee44"
   language="Lua"
   save_state="y"
   date_written="2015-05-21 08:44:48"
   requires="4.79"
   version="1.171"
   >


<description trim="n">
<![CDATA[
Commands:

tcp | tcp <index>
      -- Without argument it goes to the first mob in the table, with it goes to that number
      -- Note this will also decide if it needs to be hunted or not all by its self
tcpo | tcpo <index> 
      -- Withough argument goest to the first mob in the alternate table
tqs
      -- Quick Scan
km
      -- Sends the kill command for the last mob queued up by aknx
pt
      -- Prints the table of mobs and room numbers
pto 
      -- Prints the other list of possible room cps
wm | wm <name>
      -- Quick where for a mob name or the last mob used with aknx
cpn <index> | <mob name>
      -- Hunt trick on the given index or mob name
kcpn 
      -- turns off hunt script
TQ - not case sensitive
      -- Runs to the most probable quest room
NQ - not case sensitive
      -- Runs to the next quest room
xrt1 <area>
      -- runs to areas
tkey "<mob>" "<keywords>"
      -- Stores special keywords for a mob.
cp | gq end
      -- clears the miniwindow
tlookup name <name> level <number> room <roomname> area <areaname>
      -- This will look up mobs in the db.. 
      -- Any order and as little as one of these can be used
      -- Experimental currently
Note: 
  Adding a "Tstart" as in "mapper addnote Tstart" will tell TOL that this room is the begining of the area for this area
]]>
</description>
</plugin>
<!--  Get our standard constants -->

<include name="constants.lua"/>
  <timers>
  <timer
    name="execute_in_area_timer"
    script="execute_in_area_tick"
    enabled="n"
    second="0.25">
  </timer>
  <timer
    name="garbage_collection"
    script="collectgarbagenow"
    enabled="y"
    minute="5">
  </timer>
  </timers>
<!--  Aliases  -->

<aliases>
<alias
   enabled="y"
   match="^TOL debug on$"
   script="Toggle_Debug"
   regexp="y"
   sequence='100'
   >
  </alias>
  <alias
   enabled="y"
   match="^TOL workingMode (\d)$"
   script="workingMode"
   regexp="y"
   sequence='100'
   >
  </alias>
   <alias
   enabled="y"
   match="^TOL debug off$"
   script="Toggle_Debug"
   regexp="y"
   sequence='100'
   >
 </alias>
 <alias
   match="^printVars$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="printVars"
   regexp="y"
  >
  </alias>
  <alias
   match="^[t|T][Q|q]$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="qGoto"
   regexp="y"
  >
  </alias>
  <alias
    match="^[n|N][Q|q]$"
    enabled="y"
    send_to="12"
    sequence="100"
    script="qNext"
    regexp="y"
  >
  </alias>
  <alias
    enabled="y"
    match="^qTest$"
    script="qTest"
    regexp="y"
    sequence='100'>
  </alias>
  <alias match="^(?:TOL) help$"
    enabled="y"
    sequence="100"
    send_to="12"
    regexp="y"
    keep_evaluating="y"   
  >
  <send>
    Note(getmemoryusage())
    ColourNote("MediumSeaGreen", "", GetPluginInfo (GetPluginID (), 3))
  </send>
  </alias>
  <alias
   match="^GreedyFill (.*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script = "AutoUpdate"
  >
  </alias>
      <alias
   match="^wm (.*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="whereMob"
   regexp="y"
  >
  </alias>
      <alias
   match="^wm$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="whereMob"
   regexp="y"
  >
  </alias>
      <alias
   match="^km$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="killMob"
   regexp="y"
  >
  </alias>
   <alias
   name="cp_check"
   script="cp_check"
   match="^(cp|campaign) (c|ch|che|chec|check)$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to='12'
  >
  <send>Send('cp check')
  EnableTrigger('camp_item_start', 1)</send>
  </alias>
  <alias
   name="gq_check"
   script="gq_check"
   match="^gq (c|ch|che|chec|check)$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to="12"
  >
  <send> EnableTrigger('camp_item_start', 1)
  </send>
  </alias> 
  <alias
   match="^tcp$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="gotoNextMob"
   regexp="y"
  >
  </alias>
  <alias
   match='^tkey \"(.*?)\" \"(.*?)\"$'
   enabled="y"
   send_to="12"
   sequence="100"
   script="add_Keywords"
   regexp="y"
  >
  </alias>
  <alias
   match="^tcpo (.*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="tcpohandler"
   regexp="y"
  >
  </alias>
  <alias
   match="^tcpo$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="tcpohandler"
   regexp="y"
  >
  </alias>
  <alias
   match="^tcp (\d*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="gotoIndexMob"
   regexp="y"
  >
  </alias>
  
  <alias match="^xru?n?to?1 (.+)$"
    enabled="y"
    sequence="100"
    script="xrun_to1"
    regexp="y"
  >
  </alias>
  <alias match="^xma?p?p?e?r?1 move (?<roomid>[0-9]+) ?(?<speed>run|walk)?$"
  enabled="y"
  sequence="95"
  script="move_trigger"
  regexp="y"
  >
  </alias>
  
    <alias
   match="^pt$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="printTable"
   regexp="y"
  >
  </alias>
   <alias
   match="^pto$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="printTable1"
   regexp="y"
  >
  </alias>
      <alias
   match="^aknx (.*?)$"
   enabled="n"
   send_to="12"
   sequence="100"
   script="gotoIndexMob"
   regexp="y"
  >
  </alias>
  <alias
   match="^(cp|campaign|gq|globalquest) end$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="cpgq_quit"
  >
  </alias>
<!-- the group that controlls the hunting aspects -->
<alias
   match="^cpn (.*?)$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="cpn_script"
  >
  </alias>
  <alias
   match="^cpn$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="cpn_script"
  >
  </alias>
  <alias
   match="^kcpn$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="hunt_off"
  >
  </alias>
  <alias
   match="^rt (.*?)$"
   enabled="n"
   send_to="12"
   regexp="y"
   sequence="100"
  >
  <send>
    Execute("recall")
    Execute("runto %1")
  </send>
  </alias>
   <alias
   match="^tqs$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="quickScan"
   regexp="y"
  >
  </alias>
  <alias
  match="^TOL mktcount"
  enabled="y"
  send_to="12"
  regexp="y"
><send>Note("mktbl count = ".. #mobktbl)</send>
</alias>
<alias match="^TOL mktentry ([0-9]+)"
  enabled="y"
  send_to="12"
  regexp="y"
  >
  <send>Note("mobktbl[" .. %1 .. "]: " .. mobktbl[%1].name .. " Roomid: " .. mobktbl[%1].room_id .. " TimesKilled: " .. mobktbl[%1].timeskilled)</send>
  </alias>
  <alias
   match="^tlookup (.*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="lookup"
   regexp="y"
  >
  </alias>
</aliases>
<triggers>
   <trigger
   enabled="n"
   match="^You still have to kill (?&lt;num&gt;[\d]*)?\s?\* (?&lt;name&gt;.*?) \((?&lt;location&gt;.*?)(?&lt;dead&gt; - Dead|)\)(|\.)$"
   name="campaign_item"
   script="campaign_item"
   sequence="100"
   regexp="y"
   group="campaigncheck"
   omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="n"
  match="^Note\: One or more target names in this campaign|gquest might be slightly scrambled\.$"
  name="camp_item_start"
  script="camp_item_start"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
   name="reset_cp_flag"
   custom_colour="7"
   match="CONGRATULATIONS! You have completed your campaign."
   script="reset_cp_flag"
   enabled="y"
   send_to="12"
   sequence="100"
  >
   </trigger>
  <trigger
   enabled="y"
   regexp="y"
   match="^You get (.+) corpse of (.+)\.$"
   name="mobname"
   script="Add_To_Kill_Table"
   sequence="101"
  >
  </trigger>
  <trigger
   enabled="y"
   regexp="y"
   match="^\[(?:\d+)\] Your (.*?) (.*?)(?:\!|\.) \[(?:\d+)\]$"
   name="mobnamefight"
   script="mob_name"
   sequence="1"
  >
  </trigger>
  <trigger
   enabled="y"
   regexp="y"
   match="^Your (.*?) (.*?)(?:\!|\.) \[(?:\d+)\]$"
   name="mobnamefight1"
   script="mob_name"
   sequence="1"
  >
  </trigger>
   <trigger
   enabled="n"
   regexp="y"
   match="^Ayla gives you (.+) for the .+ corpse of (.+).$"
   name="saccorpse"
   script="mob_name"
   sequence="100"
  >
  </trigger>
 
  <trigger
  enabled="y"
  match="^(.*) tells you \'Good luck in your campaign\!\'$"
  name="camp_item"
  regexp='y'
  sequence='100'
  send_to='12'
  script="cp_check"
  omit_from_output="n"
  >
  <send>
  Send('cp check')
  EnableTrigger('camp_item_start', 1)
  timeStart()
  </send>
  </trigger>
<trigger 
    name="mob_dead"
    custom_colour="11"
    match="Congratulations, that was one of your CAMPAIGN mobs!"
    enabled="y"
    sequence="100"
    send_to="12"
    script="delete_mob_from_table"
  >
    <send>mob_index=2

    </send>
  </trigger>
  <!-- Was (?P<mob>[^0-9]){30,30} (?P<room>.+) -->
  <trigger 
    name="where_mob_trig"
    match= "^(?P<mob>[^0-9]{30,30}) (?P<room>.+)$" 
    enabled="n"
    sequence="1"
    keep_evaluating="y"
    send_to="12"
    regexp="y"
    script="where_mob_trig"
  >
  </trigger>
  
  <!-- trigers for the hunting scripts -->
  <trigger
   group="HUNTING"
   match="^You seem unable to hunt that target for some reason\.$"
   name="CPFound"
   regexp="y"
   send_to="12"
   script="CPFound"
   sequence="100"
  >
 </trigger>
  
  <trigger
   expand_variables="y"
   group="HUNTING"
   match="^You have no idea what you\'re doing\, but maybe (.*?) is (.*?)\?$"
   name="CPDoNext"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  </trigger>

  <trigger
   group="HUNTING"
   match="^(.*?) is here\!$"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  <send>
  </send>
  </trigger>
  <trigger
   group="HUNTING"
   match="^You are certain that .+ is .+ from here\.|You are almost certain that .+ is .+ from here\.|You are confident that .+ passed through here, heading .+\.|The trail of .+ is confusing, but you're reasonably sure .+ headed .+\.|There are traces of .+ having been here. Perhaps they lead .+\?|You have no idea what you\'re doing\, but maybe .+ is .+\?|You couldn\'t find a path to .+ from here\.|.+ is here\!$"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  </trigger>
  <trigger
   group="HUNTING"
   match="^No one in this area by the name \'(.*?)\'\.$"
   name="CPNotHere"
   regexp="y"
   send_to="12"
   sequence="100"
   script="not_here_script"
  >
  </trigger>
  <trigger
   group="HUNTING"
   match="^You couldn\'t find a path to (.*?) from here\.$"
   name="CPNoPath"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  <send>
</send>
  </trigger>
  <trigger
   group="HUNTING"
   match="^You have no idea what you\'re doing\, but maybe (.*?) left (.*?)\?$"
   regexp="y"
   script="incrementCounter"
   sequence="100"
  >
  <send>
</send>
  </trigger>
  <trigger
   group="Questing"
   match="^You are in area \: (.+)"
   name="questTestArea"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  
  </trigger>
  <trigger
   group="Quest"
   match="^(.*) tells you \'Seek * (.*?) out somewhere in the vicinity\'$"
   regexp="y"
   send_to="12"
   sequence="100"
   script="questMob"
   enabled="y"
  >
  </trigger>
  <trigger
   group="Quest"
   ignore_case="y"
   match="^(.*) tells you \'of (.*?) which is in the general area\'$"
   regexp="y"
   send_to="12"
   sequence="100"
   lowercase_wildcard="y"
   script="questRoom"
   enabled='y'
  >
  </trigger>
  <trigger
   group="QuestI"
   enabled="y"
   match="^(.*) can be found in the vicinity of (.*) which$"
   name="QuestInfo"
   regexp="y"
   send_to="12"
   sequence="100"
   script="QuestInfoHandle"
  >
  </trigger>
  <trigger
   group="QuestI"
   enabled="y"
   match="^is in the general area of (.*).$"
   name="QuestInfoArea"
   regexp="y"
   send_to="12"
   sequence="100"
   script="QuestInfoHandleArea"
  >
  </trigger>
  <trigger
   group="Quest"
   enabled='y'
   match="^(.*) tells you \'of (.*?)\.\'$"
   regexp="y"
   send_to="12"
   sequence="100"
   script="questArea"
  >
  <send>
  Send("q i")
  </send>
  </trigger>
  
  <trigger
   group="Quest"
   match="^QUEST\: You have almost completed your QUEST\!$"
   regexp="y"
   send_to="10"
   sequence="100"
  >
  </trigger>
  <trigger
   group="Quest"
   enabled="y"
   regexp="y"
   match="(.*)(\!|\.)  \[QUEST\]$"
   send_to="12"
   sequence="100"
   script="quest_color"
  >
  </trigger>
  <trigger
   group="Quest" 
   enabled="y"
   regexp="y"
   match="(.*)\[QUEST\]$"
   send_to="12"
   sequence="1"
   script="quest_color"
  >
  </trigger>
  <trigger
   group="Quest"
   enabled="y"
   match="^(.*) tells you \'Since the escape\, * (.*?) has murdered\'$"
   regexp="y"
   send_to="12"
   sequence="120"
   script="questMob"
  > 
  </trigger>
  
  
  <!-- Triggers for Global Quests   -->
  <trigger
  enabled="y"
  match="^Global Quest: Global quest # (?&lt;num&gt;\d*) for levels (\d*) to (\d*) - (.*) now started\.$"
  name="globalq_check"
  script="gq_check"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^Global Quest: Global quest # (?&lt;num&gt;\d*) for levels (\d*) to (\d*) has now started\.$"
  name="globalq_check1"
  script="gq_check"
  sequence='1'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^You have now joined Global Quest # (.*)\. See \'help gquest\' for available commands\.$"
  name="globalq_start"
  script="gq_start"
  sequence='1'
  regexp="y"
  omit_from_output="n"
  >/
  </trigger>
  <trigger
  enabled="y"
  match="^Congratulations\, that was one of the GLOBAL QUEST mobs\!$"
  name="globalq_delete"
  script="delete_mob_from_table"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^You were the first to complete this quest!|Global Quest: Global quest # (.*) (\(.*\))? is now over.|You are no longer part of Global Quest # (.*) and will be unable to rejoin.$"
  name="globalq_end"
  script="gq_end"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^You are not in a global quest.|You were the first to complete this quest!$"
  name="globalq_noton"
  script="gq_end"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  </triggers>
  <timers>
  <timer name="grbg" enabled="y" minute="59" second="0.00" offset_second="0.00"    send_to="12"
>
  <send>
   DebugNote(collectgarbage("count")*1024)
  collectgarbage("collect")
  DebugNote(collectgarbage("count")*1024)
  
   </send>

  </timer>
</timers>
<!--  Script  -->

<script>
<![CDATA[
dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

require "tprint"
require "KillTable"
require "pluginhelper"
require "serialize"
require "questhandle"
require "socket"

ThreadHolder= coroutine.running()
counter = tonumber(1)
counter1 = tonumber(1)
--google maps api key  AIzaSyCngIixf6KAv8_LQ9aIjAS6FpmFaM0haEc 
local Debug = false
local currentRoom
local char_status
local currentState
local tableNumHolder
local charname
local GQ_flag = false
local GQ_num
local started = false
mylevel = 0
mytier = 0
mobsleft= {}
cp_mobs= {}
local qmob

timestart= 0
timeend= 0
function hunt_off()
  Note('Turning off cpn script.')
  EnableTriggerGroup("HUNTING", false)
end
function getmemoryusage()
    collectgarbage('collect')
   return collectgarbage('count')
  end
function timeStart()
timestart = socket.gettime()
end
function timeEnd()
  timeend = socket.gettime()
  print ((timeend-timestart)/60)
end
function lookup(name1, line, wildcards)--Looks up mobs from the CPmobs database based off of name, level, area, or room
  local modifiers = {'name', 'level', 'area', 'room'}
  local ptr = 0
  local ptrkeep = 1
  local mobbuff ={}
  local decideQ = 0
  local level = 0
  local modanddata = {}
  -- for i, p in pairs(modifiers) do 
    table.insert (modanddata, p)
  -- end

  for i, p in pairs (modifiers) do
    -- print (string.sub(wildcards[1],string.find(wildcards[1], p), string.find(wildcards[1], ) ))
    -- print ('On: '.. p)
    local x, a = 0
   a,x = string.find(wildcards[1], p.." ")
    if a ~= nil and x ~= nil then 
      
        
        tmp = string.sub (wildcards[1], x)
        ptr = string.len(tmp)
        -- print (tmp)
        -- print (ptr)
        for j, k in pairs(modifiers) do
          y, w = string.find(tmp, k.." ")
          -- print(j)
          -- print (k)
          -- print (y)
          -- print (w)
          if y~= nil and y< ptr then
            -- print (y)
            ptr = y -2
          end
        end

        -- print ('Stuff to save: ' ..string.sub(tmp, 2, ptr))
        modanddata[i] = string.sub(tmp, 2, ptr)
        prt = 1
        -- print ('a: '.. a)
        -- print ('junk: '..string.sub(wildcards[1], a, x))
        -- print ('x:' ..x)
      
      if x ~= nil and x > ptr then 
        ptr = x 
        
        -- if a ~= nil and a > ptrkeep then -- this is the data to save from LAST run of the for loop
        --  print ('Stuff to save: ' ..string.sub(wildcards[1], ptrkeep+1, a-2)) 
        -- end
        -- if i ==1 then 
        --   decideQ = decideQ + 1
        -- elseif i == 2 then
        --   decideQ = decideQ + 3
        -- elseif i == 3 then
        --   decideQ = decideQ + 7
        -- elseif i == 4 then
        --   decideQ = decideQ + 11
        -- end
      end
       -- print (ptr)
       -- print (name)
       -- name =string.sub(wildcards[1], ptr+1)
       -- print (name)
       ptr = 0
       -- print ("")
    else 
      modanddata [i] = -1
    end
  end
        --tprint(modanddata)


  -- name =string.sub(wildcards[1], ptr+1)
   -- print (name)
  -- --tprint(wildcards)
  -- name = "%"..name.."%"
  -- modanddata will always be in the form 1 = name, 2 = level, 3 = area, 4 = room
  local name =""
  local levela = 0
  local levelb = 0
  local room = ""
  local area = ""
  if modanddata[1] ~= -1 then --name
   name = modanddata[1] 
   decideQ = decideQ +1
  end
  if modanddata[2] ~= -1  then --level
    if tonumber(modanddata[2]) == nil then
      print ("Level needs to be a number")
      return
    end
   levela = tonumber(modanddata[2]) +11 
   levelb = tonumber(modanddata[2]) -11
   decideQ = decideQ + 9
  end
  if modanddata[3] ~= -1  then area = modanddata[3] decideQ = decideQ +12 end -- area
  if modanddata[4] ~= -1  then room = modanddata[4] decideQ = decideQ +15 end -- room
  --print (decideQ)
  if decideQ == 0 then print('Nothing found try something else or check your usage') return end
  if decideQ == 1 then -- name or default
    query = string.format("SELECT * from CPMobs where name like %s", fixsql(name))
  elseif decideQ == 9 then-- level only
    query = string.format("SELECT * from CPMobs where level <= %d and level >= %d", levela, levelb)
  elseif decideQ == 12 then -- area only
    query = string.format("SELECT * from CPMobs where area_name like %s", fixsql(area))
  elseif decideQ == 15 then -- room only
    query = string.format("SELECT * from CPMobs where room_name like %s", fixsql(room))
  elseif decideQ == 10 then -- name and level
    query = string.format("SELECT * from CPMobs where name like %s and level <= %d and level >= %d", fixsql(name), levela, levelb)
  elseif decideQ == 13 then -- name and area
    query = string.format("SELECT * from CPMobs where name like %s and area_name like %s", fixsql(name), fixsql(area))
  elseif decideQ == 16 then -- name and room
    query = string.format("SELECT * from CPMobs where name like %s and room_name like %s", fixsql(name), fixsql(room))
  elseif decideQ == 21 then -- level and area
    query = string.format("SELECT * from CPMobs where level <= %d and level >= %d and area_name like %s",levela, levelb, fixsql(area))
  elseif decideQ == 24 then -- level and room
    query = string.format("SELECT * from CPMobs where level <= %d and level >= %d and room_name like %s", levela, levelb, fixsql(room))
  elseif decideQ == 27 then -- area and room this shouldn't really happen but fuck it, its an option now
    query = string.format("SELECT * from CPMobs where area_name like %s and room_name like %s", fixsql(area), fixsql(room))
  elseif decideQ == 25 then -- name, level, room
    query = string.format("SELECT * from CPMobs where name like %s and level <= %d and level >= %d and room_name like %s", fixsql(name), levela, levelb, fixsql(room))
  elseif decideQ == 37 then -- name, level, room, area
    query = string.format("SELECT * from CPMobs where name like %s and level <= %d and level >= %d and room_name like %s and area_name like %s", fixsql(name), levela, levelb,fixsql(room), fixsql(area))
  elseif decideQ == 28 then -- name, room, area
    query = string.format("SELECT * from CPMobs where name like %s and room_name like %s and area_name like %s", fixsql(name), fixsql(room), fixsql(area))
  elseif decideQ == 22 then -- name, level, area 
    query = string.format("SELECT * from CPMobs where name like %s and level <= %d and level >= %d and area_name like %s", fixsql(name), levela, levelb, fixsql(area))
  elseif decideQ == 36 then -- level, room, area
    query = string.format("SELECT * from CPMobs where level <= %d and level >= %d and room_name like %s and area_name like %s", levela, levelb,fixsql(room), fixsql(area))

  end
  -- print (query)
  for p in dbkt:nrows(query) do
    table.insert(mobbuff, p )
  end
  tprint (mobbuff)
  if decideQ == 1 and #mobbuff <1 then 
    -- print ('test')
    query = string.format("SELECT * from mobkills where name like %s group by room_id", fixsql(name))
    for p in dbkt:nrows(query) do
      table.insert(mobbuff, p)
    end
  end
  if #mobbuff<1 then
    print ("OKYDOKY BOSS NOTHING TO SEE HERE")
    print ("seriously though we found nothing")
  end
end
function quickScan()
  Execute("scan " .. mobname)
end
function workingMode(name, line, num)
  local numt = tonumber(num[1])
  print ("test")
  print (numt==1)
  tprint(GetTimerList())
  if numt == 1 then
    print("Working mode on")
    
    dbkt:close()
  elseif numt == 0 then
    print("Working mode off")
    
    print (GetPluginInfo (GetPluginID (), 20))
    dbkt=sqlite3.open(GetPluginInfo (GetPluginID (), 20) .. 'KillTable.db')
    dbkt:busy_handler(myHandler)
    
  end
end

function Toggle_Debug(name, line, wildcards)
  if string.find(line, "on") then
    Note ("Turning Debugging on")
    Debug = true
  else
    Note ("Turning Debugging off")
    Debug = false
  end
end

function QuestInfoHandle(name, line, wildcards)
  qMob(wildcards[1])
  qRoom(wildcards[2])
  mobname = sanitizeName(wildcards[1])
end

function QuestInfoHandleArea(name, line, wildcards)
  qArea(wildcards[1])
end

function questMob(name, line, wildcards)
  qMob(wildcards[2])
  mobname = sanitizeName(wildcards[2])
end

function questRoom(name, line, wildcards)
-- print (wildcards[2])
qRoom(wildcards[2])
end

function questArea(name, line, wildcards)
  -- print (wildcards[2])
qArea(wildcards[2])
end

function cp_check( name, line, wildcards)
  EnableTrigger("campaign_item", true)

  mobsleft = {}
end -- cp_check
function gq_check( name, line, wildcards)
  DebugNote( "gq_check")
  DebugNote(wildcards)
  GQ_flag = true
  EnableTrigger('camp_item_start', 1)
  DebugNote("GQ_flag set to "..tostring(GQ_flag))
  if wildcards ~= nil and tonumber(GQ_num) == tonumber(wildcards.num) then
    EnableTrigger("campaign_item", true)
    DebugNote("Gquest started")
    
-- this is sublime text ahh
    GQ_num = tonumber(wildcards[1])
    DebugNote (GQ_num)
    Send("gq ch")
    mobsleft = {}

  elseif #wildcards <=1 then
    EnableTrigger("campaign_item", true)
    Send("gq ch")
    mobsleft = {}
  elseif tonumber(wildcards.num) ~= tonumber(GQ_num) then
    GQ_flag = false
    DebugNote("Shutting GQ_flag off")
    EnableTrigger('camp_item_start', 0)
  end
end -- gq_check
function gq_start(name, line, wildcards)
  DebugNote ("gq_start")
  --EnableTrigger("campaign_item", true)
  GQ_num = tonumber(wildcards[1])
  DebugNote (GQ_num)
  GQ_flag = true
  DebugNote("GQ_flag set to "..tostring(GQ_flag))
  mobsleft = {}
end
function cpgq_quit(name, line, wildcards)
  DebugNote(name)
  DebugNote(line)
  DebugNote(wildcards)
  if wildcards[1] == "gq" then
    GQ_flag = false
    DebugNote("GQ_flag set to "..tostring(GQ_flag))
  end
  DebugNote("cpgq_quit")
  phelper:broadcast(4)
  cp_mobs = {}
  clearTable()
end

function gq_end(name, line, wildcards)
DebugNote(wildcards)
  if GQ_flag == false then return end
  if wildcards[1] == GQ_num then
    DebugNote("if block")
    GQ_flag = false
    DebugNote("GQ_flag set to "..tostring(GQ_flag))
    phelper:broadcast(4)
    cp_mobs = {}
    clearTable()
  elseif #wildcards<1 then 
    DebugNote("elseif block")
    GQ_flag = false
    DebugNote("GQ_flag set to "..tostring(GQ_flag))
    phelper:broadcast(3)
  end -- if
  DebugNote ("Gq is off now")
end

function add_Keywords(name, line, wildcards)
  if check_CPMobs_Table()<1 then 
    print ("you don't have CPMobs table, you can't use this function, try installing the CPMobs plugin")
    return 
  end
  query = string.format("UPDATE CPMobs SET keywords=%s WHERE name=%s;", fixsql(wildcards[2]), fixsql(wildcards[1]))
  querycheck = string.format("Select count(name) as count from CPMobs where name= %s;",fixsql(wildcards[1]))
  for a in dbkt:nrows(querycheck) do 
    count = a.count
    if count<1 then 
      print ("You have the name wrong, or it is not in the table, try again!")
      print ("You entered: " .. wildcards[1])
    end
  end
  if tonumber(count)<1 then
    return 
  end
  rc= dbkt:exec(query)
  print ("Added ".. wildcards[2].. " to the mob entry for ".. wildcards[1])
  if rc ~= 0 then
    Note ( DatabaseError('dbkt'))
  end--if
end

function check_CPMobs_Table()
  local count = 0
  checktable = "SELECT Count(name) as count FROM sqlite_master WHERE type='table' AND name='CPMobs';"
  for a in dbkt:nrows(checktable) do
    count = a.count
  end
  if count <1 then 
      
      return 0
  end
  return 1
end

function camp_item_start()-- get your campaign items
  clearTable()
  
  EnableTrigger('campaign_item',false)
  EnableTrigger('camp_item_start',0)
  cp_mobs = {}
  cp_mobs= mobsleft
  if myThread== nil  or coroutine.status (myThread) == "dead" then

        myThread = coroutine.create(buildRoomTable)
        AddTimer ("tickler", 0, 0, .1, "",
               timer_flag.Enabled + timer_flag.Replace,
               "tickle_it")

  end--if 
    FirstRun_cp_var= false
    check_dead()
    DebugNote(collectgarbage("count")*1024)
    collectgarbage("collect")
    DebugNote(collectgarbage("count")*1024)
    
end

function campaign_item (name, line, wildcards)-- the actual campaign item getter
  DebugNote("start cp_item mobsleft")
  DebugNote (wildcards)
  DebugNote("end cp_item mobsleft")
  name = wildcards.name
  mobdead = false
  location = wildcards.location
  num = tonumber(wildcards.num)
  if wildcards.dead ==  ' - Dead' then
    mobdead = true
  else
    mobdead = false
  end
  
  if not name or not location then
    print("error parsing line: ", line)
    --tprint(wildcards)
  else
    table.insert(mobsleft, {name=name, location=location, mobdead=mobdead, mobdead=mobdead,false, num = tonumber(num)})
  end
  end -- campaign_item

function delete_mob_from_table( )
  local found = false
  local tmp = {}
  local num
  if AutoUpdate_var == false and last_Enemy~= nil then
    for p,q in pairs (room_num_table) do
      num = tonumber(q[6]) or 1
      DebugNote (q)
      DebugNote(q[6])
      DebugNote ("Number of kills needed at time of delete_mob_from_table "..num)
      if string.lower(last_Enemy)== string.lower(q[2]) and num == 1 then
        table.remove(room_num_table,  p)
        table.remove(cp_mobs, p)
        found = true
        break
      elseif string.lower(last_Enemy)== string.lower(q[2]) then
        q[6] = q[6]-1
        cp_mobs[p].num = cp_mobs[p].num -1
        DebugNote(cp_mobs)
        DebugNote(cp_mobs[p][q])
        DebugNote ("number of mobs is ".. q[6])
        found = true
        break
      end--if
    end--for
    for p,q in pairs (room_num_table2) do
       if string.lower(last_Enemy)== string.lower(q[2]) then
        room_num_table2[p] = nil
        else 
          table.insert(tmp, room_num_table2[p])
        end--if
    end--for
    room_num_table2 = tmp
    if found == false then
      DebugNote("Begin cp_mobs[mob_next_delete_value] check")
      
      DebugNote(num)
      DebugNote("End cp_mobs[mob_next_delete_value] check")
      --tprint (cp_mobs)
      -- if cp_mobs[mob_next_delete_value][6] >1 then
      --   cp_mobs[mob_next_delete_value][6] = cp_mobs[mob_next_delete_value][6] -1
      --   room_num_table[mob_next_delete_value][6] = room_num_table[mob_next_delete_value][6] -1
      --   return
      -- end
      table.remove(room_num_table,  mob_next_delete_value)
      table.remove(cp_mobs, mob_next_delete_value)
      DebugNote(GQ_flag)
      if GQ_flag == true then
        do_Execute_no_echo("gq check")
      else
        do_Execute_no_echo("cp check")
      end--if
    end--if
    mob_index= 1
  end--if
  check_diff()
  sortRoomCPByPath()
  var.cp_mobs = serialize.save( "cp_mobs", cp_mobs )
  phelper:broadcast(1, var.cp_mobs)
  DebugNote(collectgarbage("count")*1024)
  collectgarbage("collect")
  DebugNote(collectgarbage("count")*1024)
end

function delete_mob_from_table_index(val)

  if AutoUpdate_var == false and last_Enemy ~= nil then
  for p,q in pairs (room_num_table2) do
    num = tonumber(q[6]) or 1
     if string.lower(last_Enemy)== string.lower(q[2]) then
        table.remove(room_num_table2,  p)
      end--if
  end--for
  if room_num_table[val].num == 1 then
    table.remove(room_num_table, tonumber(val))
  else
    room_num_table[val][6] = room_num_table[val][6] -1
    cp_mobs[val].num = cp_mobs[val].num -1
  end 
  DebugNote(collectgarbage("count")*1024)
  collectgarbage("collect")
  DebugNote(collectgarbage("count")*1024)
  mob_index= 1
  check_diff()
  end--if
end

function CPFound()
  if tonumber(count) >0 then
  Execute ("wm " .. count .. "." ..mobname)
  else
  Execute ("wm "  ..mobname)
  end
  EnableTriggerGroup("HUNTING", false)
end

function not_here_script()
  
  Execute("wm "..mobname)
  Note ("THIS IS NOT THE CORRECT AREA OR THE MOB IS DEAD")
  EnableTriggerGroup("HUNTING", false)
  
end

function quest_color()
  ColourNote ("white","blue","==================QUEST MOB HERE!!!!!!!!!!!!!!!!!!!!!!!=================")
end

function cpn_script (index, line, wildcards)
  -- print (index)
  -- print (line)
  local numcheck
  if wildcards ~= nil then
    numcheck = tonumber(wildcards[1])
  end
  DebugNote (index)
  DebugNote (type(index))

  --DebugNote (type(wildcards[1]))
  --DebugNote (wildcards)
  DebugNote (numcheck)
if  index ~= nil and type(index)== 'string'  then
  if #wildcards < 1 then 
      index = mob_index

    elseif #wildcards <=1 and numcheck == nil then

      EnableTriggerGroup("HUNTING", true)
      reset_counter()
      mobname = wildcards[1]
      Execute ("hunt " .. mobname)
      --EnableTriggerGroup("HUNTING", false)
      return
    end
  if wildcards[1]== nil and mob_index ~= nil then
  else
  index = wildcards[1]
  end
end --if
index = tonumber(index)
if room_num_table[index] == nil then
  print ("No cp_mob at that value")
  return
end--if
  EnableTriggerGroup("HUNTING", true)
  reset_counter()
  if room_num_table[index][1] ~= nil and cpn_is_room_type == false then
    getTable(index)
    Execute ("hunt " .. mobname)
  else
    Note("Either not on a cp or haven't checked it yet, or its a room type cp. Use hyperlink.")
    cpn_is_room_type= false
    EnableTriggerGroup("HUNTING", false)
  end
end

AutoUpdate_var = false
greedy = false
FirstRun_cp_var= true

function printVars()
  tprint (cp_mobs)
--   Debug = true
--   DebugNote({1, 2})
--   Debug = false
--   --Clean_Kill_Table()
-- cp_mobs[1]={location= 'Stairwell'
-- ,mobdead= 'false',
-- name= 'King Breolerc',
-- clean = 'King Breolerc'}
-- cp_mobs[2]={location= 'The Conservatory'
-- ,mobdead= 'false',
-- name= 'a rabbit foot fern',
-- clean = 'a rabbit foot fern'}
-- cp_mobs[3]={location= 'North West Market Square'
-- ,mobdead= 'false',
-- name= 'Mino the Crazy',
-- clean = 'mino the crazy'}
-- cp_mobs[4]={location= 'High priest quarters'
-- ,mobdead= 'false',
-- name= 'an ancient ghost',
-- clean = 'an ancient ghost'}
local llthreads = require"llthreads"
print (package.cpath)
local thread_code = [[
temp= ''
-- local socket = require"socket"
--     -- print thread's parameter.
--     --dofile ("E:\\Users\\Jeremy\\Desktop\\r1802\\MUSHclient\\worlds\\plugins\\TOL\\luapath.lua")
-- -- temp = (package.cpath)
   local status, socket = pcall(require,"socket")
    local db = pcall(require,"lsqlite3")
--     -- if temp ~='' then
--     -- temp = (package.cpath) end
--     return status, socket
--   --   print("CHILD: received params:", ...)
    local tst=sqlite3.open('E:\\Users\\Jeremy\\Desktop\\r1802\\MUSHclient\\worlds\\plugins\\TOL\\KillTable.db')
--   --   local temp
    querycheck = "Select count(name) as count from CPMobs "
  for a in tst:nrows(querycheck) do 
    temp =a.count 
  end
--   --   -- print(tst)
--   --   -- return all thread's parameters back to the parent thread.
    return temp
]]


-- create detached child thread.
-- local thread = llthreads.new(thread_code, "number:", 12345, "nil:", nil, "bool:", true)
-- start non-joinable detached child thread.
-- assert(thread:start(true))
-- Use a detatched child thread when you don't care when the child finishes.
local function print_thread(...)
  local thread = llthreads.new([[ print("print_thread:", ...); ]], ...)
  -- start joinable thread
  assert(thread:start())
  return thread
end

local thread2 = print_thread("number:", 1234, "nil:", nil, "bool:", true)
print("thread2:join: results # = ", select('#', thread2:join()))
-- create child thread.
local thread = llthreads.new(thread_code, "test:", 1111)
-- start joinable child thread.
assert(thread:start())
-- Warning: If you don't call thread:join() on a joinable child thread, it will be called
-- by the garbage collector, which may cause random pauses/freeze of the parent thread.
-- luastmt = "gmcpdata = " .. thread:join()
--         assert (loadstring (luastmt or "")) ()
-- print(gmcpdata)
--print("thread:join: results # = ", select('3', thread:join()))
print("PARENT: child returned: ", thread:join())
--tprint (select('3', thread:join())
-- local socket = require"socket"
-- socket.sleep(2) -- give detached thread some time to run.
if myThread== nil  or coroutine.status (myThread) == "dead" then

        myThread = coroutine.create(buildRoomTable)
        AddTimer ("tickler", 0, 0, .1, "",
               timer_flag.Enabled + timer_flag.Replace,
               "tickle_it")
      end--if 
 tprint(cp_mobs) 
 tprint(room_num_table)

DebugNote(collectgarbage("count")*1024)
DebugNote("Mem Usage " .. collectgarbage("count"))
DebugNote(collectgarbage("count")*1024)
 phelper:broadcast(4)
 --test
-- collectgarbage("count")
end
kill_info = {}
-- I hate to do it this way and will come up with a better solution... but for now
damage_verbs = {'misses ',
' tickles ',
' bruises ',
' scratches ',
' grazes ',
' nicks ',
' blasts',
' scars ',
' hits ',
' injures ',
' wounds ',
' mauls ',
' maims ',
' mangles ',
' mars ',
' massacres ',
' dismembers ',
' devastates ',
' disembowels ',
' lacerates ',
' LACERATES ',
' DECIMATES ',
' DEVASTATES ',
' ERADICATES ',
' OBLITERATES ',
' EXTIRPATES ',
' INCINERATES ',
' MUTILATES ',
' DISEMBOWELS ',
' MASSACRES ',
' DISMEMBERS ',
' RENDS ',
' meteorites ',
' glaciates ',
' nukes ',
' implodes ',
' asphyxiates ', --
' liquidates ', -- 
' fissures ', --
' exterminates ', --
' ravages ', --
' atomizes ', --
' sunders ', --
' tears into ', --
' destroys ', --
' pulverizes ', --
' demolishes ', --
' mutilates ', --
' incinerates ', --
' extirpates ', --
' obliterates ', --
' eradicates ', --
' annihilates ',-- nnih%
' evaporates ',-- vapor%
' ruptures ',-- upt%
' shatters ',-- hatter%
' slaughters ', -- laughters%
' vaporizes ',--vapor%
' wastes ',-- astes%
' shreds ',
' cremates ', -- remat%
' supernovas ',
' The charge slams into ',
' does UNSPEAKABLE things to ',
' does UNTHINKABLE things to ',
' does UNIMAGINABLE things to ',
' does UNBELIEVABLE things to ',
' %- BLASTS %- ',
' %-= DEMOLISHES =%- ',
' %*%* SHREDS %*%* ',
' %*%*%*%* DESTROYS %*%*%*%* ',
' %*%*%*%*%* PULVERIZES %*%*%*%*%* ',
' %-=%- VAPORIZES %-=%- ',
' <%-==%-> ATOMIZES <%-==%-> ',
' <%-:%-> ASPHYXIATES <%-:%-> ',
' <%-%*%-> RAVAGES <%-%*%-> ',
' <>%*<> FISSURES <>%*<> ',
' <%*><%*> LIQUIDATES <%*><%*> ',
' <%*><%*><%*> EVAPORATES <%*><%*><%*> ',
' <%-=%-> SUNDERS <%-=%-> ',
' <=%-=><=%-=> TEARS INTO <=%-=><=%-=> ',
' <%->%*<=> WASTES <=>%*<%-> ',
' <%-%+%-><%-%*%-> CREMATES <%-%*%-><%-%+%-> ',
' <%*><%*><%*><%*> ANNIHILATES <%*><%*><%*><%*> ',
' <%-%-%*%-%-><%-%-%*%-%-> IMPLODES <%-%-%*%-%-><%-%-%*%-%-> ',
' <%-><%-=%-><%-> EXTERMINATES <%-><%-=%-><%-> ',
' <%-==%-><%-==%-> SHATTERS <%-==%-><%-==%-> ',
' <%*><%-:%-><%*> SLAUGHTERS <%*><%-:%-><%*> ',
' <%-%*%-><%-><%-%*%-> RUPTURES <%-%*%-><%-><%-%*%-> ',
' <%-%*%-><%*><%-%*%-> NUKES <%-%*%-><%*><%-%*%-> ',
' %-<%[=%-%+%-=%]<:::<>:::> GLACIATES <:::<>:::>%[=%-%+%-=%]>%- ',
' <%-=%-><%-:%-%*%-:%-><%*%-%-%*> METEORITES <%*%-%-%*><%-:%-%*%-:%-><%-=%-> ',
' <%-:%-><%-:%-%*%-:%-><%-%*%-> SUPERNOVAS <%-%*%-><%-:%-%*%-:%-><%-:%-> ',
}
function mob_name(name,line,wildcards)

    if string.find(line, "%!") ~= nil then
      temp= string.sub(line, 10, string.find(line, "%!")-1 )
    elseif string.find(line, "%.") then
      temp= string.sub(line, 10, string.find(line, "%.")-1 )
    end--if
    DebugNote (temp)
    for i,v in pairs(damage_verbs) do
      o, p =string.find(temp, v)  
      if p ~= nil then
        DebugNote (o.. " "..p.. " " .. v)
        DebugNote(temp)
        temp = string.sub(temp, p+1, #temp)
        last_Enemy = temp
        DebugNote(temp)
        return
      end--i
    end--for
    i = string.find(temp, "%A")
    while i  do 
      temp= string.sub(temp, i+1, #temp )
      i=string.find(temp, "[%A][%s]")
      DebugNote (i)
    end -- while
    temp= string.sub(temp, 2, #temp )
    last_Enemy= temp
end
function Add_To_Kill_Table(name, line, wildcards)
  if greedy == false then
    return
  end--if
  kill_info.room_id= currentRoom.roomid
  kill_info.name= last_Enemy
  Add_Kill_Table(kill_info)
end

function check_dead ()
  check_diff()
  --DebugNote(cp_mobs)
    --DebugNote(room_num_table)
  for p, q in ipairs(room_num_table) do
   -- print(p)
    --tprint(q)
   -- DebugNote (cp_mobs[p])
    if cp_mobs[p].mobdead ~= nil then
      if  q[2] == cp_mobs[p].name and cp_mobs[p].mobdead == true  then --used to be k.name and k.mobdead in case it doesn't work
        room_num_table[p][3] = true
      else 
        room_num_table[p][3]= false       
      end--if 
    end     
  end--for
end

function check_diff()
  if AutoUpdate_var== true then
    return
  end--if
    for p, q in pairs(room_num_table) do
     
      if cp_mobs[p]== nil then
         --print (p)
        --tprint (q)
        delete_mob_from_table_index(p)
        return
      end--if 
      if string.lower(q[2])~= string.lower(cp_mobs[p].name) and #room_num_table > #cp_mobs  then 
       delete_mob_from_table_index(p) -- not sure if this is working yet
       DebugNote ("If you see this message this was the function causing the stack overflow")
       elseif string.lower(q[2])~= string.lower(cp_mobs[p].name) and #room_num_table < #cp_mobs then
      DebugNote('room <cp_mobs and names dont match')
        if myThread== nil  or coroutine.status (myThread) == "dead" then
          myThread = coroutine.create(buildRoomTable)
          AddTimer ("tickler", 0, 0, .1, "",
             timer_flag.Enabled + timer_flag.Replace,
             "tickle_it")
        end--if
        return
      end--if
      if string.lower(q[2])~= string.lower(cp_mobs[p].name) and #room_num_table == #cp_mobs then
       DebugNote('room ==cp_mobs and names dont match')
       DebugNote(q[2].. " ".. cp_mobs[p].name)
        if myThread== nil  or coroutine.status (myThread) == "dead" then
          myThread = coroutine.create(buildRoomTable)
          AddTimer ("tickler", 0, 0, .1, "",
             timer_flag.Enabled + timer_flag.Replace,
             "tickle_it")
          
        end--if
      end--if
    end--for  
  mob_index= 1
  var.cp_mobs = serialize.save( "cp_mobs", cp_mobs )
  phelper:broadcast(1, var.cp_mobs)
end
myThread= nil
local level = 0
local oldlevel = 0
 function OnPluginBroadcast (msg, id, name, text)
  
  if (id == '3e7dedbe37e44942dd46d264') then
      if (text == "room.info") then
        res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
        luastmt = "gmcpdata = " .. gmcparg
        assert (loadstring (luastmt or "")) ()
        currentRoom = {
          roomid = gmcpdata.num,
          areaid = gmcpdata.zone
        }
        started = true
        OnPluginInstall()
      end
      if (text == "char.status") then
        res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.status")
        luastmt = "gmcpdatacharstatus = " .. gmcparg
        assert (loadstring (luastmt or "")) ()
        char_status = gmcpdatacharstatus
        mylevel = tonumber(gmcpdatacharstatus.level)
        started = true
       OnPluginInstall()
       if (text == "char.base") then
         res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.base")
         luastmt = "gmcpdata = " .. gmcparg
         assert (loadstring (luastmt or "")) ()
         mytier = tonumber(gmcpdata.tier)
      end

       if level == 0 then
        level = tonumber(char_status.level) 
        oldlevel = level
        -- put in logic for getting the cpmobs table
        CpMobsAbr(level)
       end

       if level ~= oldlevel then
        CpMobsAbr(level)
        oldlevel = level
       end

      end
      if (text == "char.base") then
        res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.base")
        luastmt = "gmcpdatacharstatus = " .. gmcparg
        assert (loadstring (luastmt or "")) ()
        char_base= gmcpdatacharstatus
      end
    end
end
CPMobsLevelBound = nil
-- takes a level and makes a CPmobs table that is within 30 level of our current level
function CpMobsAbr(str)
  levelAdj= 30
  levmin = tonumber(str)-levelAdj
  levmax = tonumber(str)+levelAdj
  query = string.format("select *, count(*) as timeskilled from CPMobs "..
    " where level < %s and level > %s "..
    " group by room_id order by  name, timeskilled desc", levmax, levmin)

  c = 0
  CPMobsLevelBound = {}
  for rows in dbkt:nrows(query) do
    c = c+1
    CPMobsLevelBound[c] = {
    name = rows.name,
    room_id = rows.room_id,
    room_name = rows.room_name,
    area_name = rows.area_name,
    level = rows.level
  }
  end

end

function tickle_it ()

  -- if background task exists, and is suspended, resume it
  if myThread ~= nil and
     coroutine.status (myThread) == "suspended" then
    coroutine.resume (myThread)
  else
    EnableTimer ("tickler", false)  -- don't need timer now
  end -- if
end -- tickle_it 

function AutoUpdate(name, line, wildcards)
   if wildcards[1] == 'true' or wildcards[1] == 'True'  then
    greedy = true
    Note ("Greedy fill changed to: ".. tostring(greedy).. type(greedy))
   else
    greedy= false
    Note ("Greedy fil changed to: ".. tostring(greedy).. type(greedy))
    end--if
    SetVariable("greedy","greedy ="..serialize.save_simple(greedy))
end

room_num_table = {}

function clearTable()
  room_num_table= {}
  room_num_table2= {}
end

function makeTable(room_num, name, bool, isInTable, area, num)-- stores all names and room numbers into a global table
  room_num_table[counter]= {room_num, name, bool, isInTable, area, tonumber(num)}
  counter= counter + 1
  

end
function makeTable2(room_num, name, bool, inTable, area)-- stores all names and room numbers into a global table
  room_num_table2[counter1]= {room_num, name, bool, inTable, area}
  counter1= counter1 + 1
  

end
function printTable() -- prints the global table for names and room numbers, used for debugging or quick checking
 if room_num_table ~= nil and #room_num_table>0 then
  tprint(room_num_table)
  DebugNote(cp_mobs)
  else
    print ("Nothing to print")
  end--if
end

function printTable1() -- prints the global table for names and room numbers, used for debugging or quick checking
 if room_num_table2 ~= nil and #room_num_table2>0 then
  tprint(room_num_table2)
  else
    print ("Nothing to print")
  end--if
end

curMob= ''
mobname= ''
word_count= tonumber(0)

function getTable(index) -- returns the first item in the table of room numbers, also makes a variable 'mobname' which is used for the autokill comand
    if room_num_table[index]== nil then
      return -1
    end
      local num =room_num_table[tonumber(index)][1]
      curMob= room_num_table[tonumber(index)][2]
    getName(index, 1)
    return num
end

function getName(index, num)
  local s= ''
  if cp_mobs== nil then
    print ("Use akn before that command please")
    return
  end--if
  s = room_num_table[tonumber(index)][2] or curMob
 mobname = sanitizeName(s)
end

function sanitizeName(s)
local exit = 0
if s==nil then
  Note("s was nil")
  return
end
if check_CPMobs_Table()>0 then-- this needs to be reworked once all versions are unified. Aka when all versions have CPMobs support for Room CPs
  check_Keywords = string.format("SELECT keywords from CPMobs WHERE name= %s and keywords <> '';", fixsql(s)) 
  if dbkt:exec(check_Keywords) == 0 then
    DebugNote("Was not busy on database call")
    for keys in dbkt:nrows(check_Keywords) do
      DebugNote(keys)
      if keys.keywords ~= nil and keys.keywords ~= '' then
        mobname = keys.keywords
        exit = 1
      end
    end
  else
    DebugNote("The call in sanatize name to keywords was busy")
  end
  if exit == 1 then
    return mobname
  end
end
  local s2= {}
  s =string.gsub(s, "-", " ")
  s =string.gsub(s, "'", " ")
  s =string.gsub(s, "%@r", " ")
  for i in s:gmatch( "%a+") do
    word_count = tonumber(word_count) + 1
    s2[word_count]= i
    s2[word_count]= string.gsub(s2[word_count] , ",", " ")
  end -- for
  word_count= 0
  if (s2[1] == "a" or s2[1] == "A" or s2[1] == "An" or s2[1] == "the" or s2[1] == "The" or s2[1] == "an") and table.getn(s2) >1 then
    if table.getn(s2)>2
    then
      s2[2]= string.sub(s2[2], 0, 3)
      s2[3] = string.sub(s2[#s2],0, 3)
      mobname = s2[2].." "..s2[3]
      else
      mobname = s2[2] 
    end -- if
  else
  if table.getn(s2)>1
  then
    s2[1]= string.sub(s2[1], 0, 3)
    s2[2] = string.sub(s2[#s2],0, 3)
    mobname = s2[1].." "..s2[2]
  else
    mobname = s2[1]
  end--if
  end--if
    return mobname
end  
    
function buildRoomTable()-- This sends the table to get room_ids
--local time1 = socket.gettime()*1000
  if cp_mobs ==nil then
      cp_mobs = mobsleft
  end
  counter = tonumber(1)
  counter1 = tonumber(1)
  FirstRun_cp_var = false
  clearTable()
  local roomCPCheck = 0
  for i,v in ipairs (cp_mobs) do
    roomCPCheck = getRoomId(cp_mobs[i].name, i )
    -- if (i%3== 0)then
    --   coroutine.yield(myThread)
    -- end--if
  end
    coroutine.yield(myThread)
  for i,v in ipairs(room_num_table) do
    if (room_num_table[i][4]== false) then
      cp_mobs[i].intable = false
    else
      cp_mobs[i].intable = true
    end--if
  end --for
  -- if roomCPCheck == 1 then
  --   sortRoomCP()
  -- end
  sortRoomCPByPath()
  
  var.cp_mobs = serialize.save( "cp_mobs", cp_mobs )
  phelper:broadcast(1, var.cp_mobs)
  --local time2 = (socket.gettime()*1000) - time1
  --DebugNote("Time to build table is ".. time2)
end

local shortaname 

function getRoomId(name, tableNum)-- Gets a roomId from campaign
local loc = cp_mobs[tableNum].location
dbA=sqlite3.open(GetInfo (66) ..'Aardwolf.db')
  if dbA:isopen() then
    local query1 = "select rooms.uid as room, rooms.name as roomName, rooms.area as area, areas.name as areaName, 'room' as type "..
        " from rooms rooms, areas "..
        " where areas.uid = rooms.area and "..
        " rooms.name = %s "..
        " union "..
        " SELECT rooms.uid as room, rooms.name as roomName, areas.uid as area, areas.name as areaName, 'area' as type" ..
        " FROM areas, rooms " ..
        " WHERE areas.name = %s and "..
        "rooms.area = areas.uid "..
        " ORDER BY type ASC "
    sql_now= string.format(query1, fixsql(loc), fixsql(loc) )
    local count_check= 0
    local hld = {}
    for rows in dbA:nrows(sql_now) do
     
      table.insert(hld, rows)
    end -- for
    for g, rows in pairs(hld) do
      
      if rows.type== 'room' then
        getRoomIdRoomCP(name,name, tableNum)
        dbA:close()
        return 1
      else
        getRoomIdAreaCP(name, tableNum)
        dbA:close()
        return 0
      end--if
    end 
  end--if
end
sublist={1,1}
function testtime(name)
  sublist={}
  --time =socket.gettime()
  --local c = 0
 -- print (#mobktbl)
for i, p in pairs(mobktbl) do
--c = c+1
--if c == 7077 then print (string.format("This item is %s %s %s"), i, p.room_id, p.timeskilled) end
  if p.name == name then 
   -- print ("inserted ".. p.name .. " at ".. p.room_id .. " i= ".. i)
    table.insert(sublist, {p.name, p.room_id, p.timeskilled})
  end
end
-- so is testtime called repeatedly? and when?
--print (c)
  --time2 = (socket.gettime()-time)*1000
  --print ("time to get sub table was ".. time2)
end
function getRoomIdAreaCP(name, tableNum)
local nameHolder= nil
local roomNumber= nil
local roomTemp= nil
local loc = cp_mobs[tableNum].location
local dbArea = dbA
local dbKillT = dbkt --dbkt assigner
local found = false
local time1 = socket.gettime()
local thisrooms = rooms
local thisareas = areas
    local  cpmobquery = string.format("select room_id, area_name, name, COUNT(*) as timeskilled "..
        "from CPMobs "..
        "where name like %s and "..
        "area_name = %s "..
        "group by room_id, name "..
        "ORDER by timeskilled asc ", fixsql(name), fixsql(loc))
      -- DebugNote(fixsql(name))
      -- DebugNote(fixsql(loc))
    -- local  query = string.format("select room_id, name, COUNT(*) as timeskilled "..
    --     "from mobkills "..
    --     "where name like %s "..
    --     "group by room_id, name "..
     --   "ORDER by timeskilled desc ", fixsql(name))
      -- rc = dbKillT:exec(cpmobquery)
      -- DebugNote(rc)
      -- DebugNote(dbKillT:errmsg())
    if CPMobsLevelBound ~= nil then
      --print("using CPMobsLevelBound first")

      for i, p in pairs(CPMobsLevelBound) do
        if name == p.name and loc == p.area_name then 
          --print ("found one".. name)
          nameHolder = name
          roomNumber = p.room_id
          found = true
        end
      end
    end
    if found == false then
      for a in dbKillT:nrows(cpmobquery) do
         DebugNote(a)
        if found== false then
          nameHolder = a.name
          roomNumber = a.room_id
          found = true
         -- print ("found in the CPMob table")
        end
      end   
  end
    local count= 0
    if found == false then 
      testtime(name)-- this gets called every mob in your cp list let me show you the flow
      --tprint (sublist)
     DebugNote("\n In second block ".. name.."\n")
     
      --for a in dbKillT:nrows(query) do
      for i,a in pairs(sublist) do
      count = count+1 
      --print (count)
        DebugNote(a)
        DebugNote("-----")
        -- print (tostring(found))
        nameHolder=a[1]
        roomTemp= tostring(a[2])
        -- print (roomTemp)
          -- query1 = string.format("select rooms.uid, areas.name as areaName "..
          --   "from rooms, areas "..
          --   "where areas.uid = rooms.area and rooms.uid = %s and areaName = %s",fixsql(roomTemp), fixsql(loc))
          --print (tostring(found))
          if found == false then
            --for rows in dbA:nrows(query1) do
            --for i, v in pairs (thisrooms)
           -- print ("Test")
           -- tprint (rooms[tostring(roomTemp)])
           -- print (thisrooms[roomTemp].area)
           -- print ("test2")
           --tprint (thisrooms[roomTemp])
           if thisrooms[roomTemp] ~= nil then  
             --print (thisareas[thisrooms[roomTemp].area].name)
             -- print (loc)
              --print (tostring(found))
              --tprint(thisareas[thisrooms[roomTemp]])
              if loc == thisareas[thisrooms[roomTemp].area].name and found == false then
                DebugNote(a[1])
                found = true
                roomNumber = roomTemp
              end
                -- count = count+1
                -- DebugNote(rows)
                DebugNote("+++++")
                -- if rows.areaName == cp_mobs[tableNum].location and found == false then
                --   roomNumber= roomTemp 
                --   found = true
                -- end --if
              --end -- for
            end
          end
          -- if nameHolder ~= nil and roomNumber ~= nil  then
          --   dbA:interrupt()
          -- end--if
      end --for
    end --if
    --print (count)
    local time2 = (socket.gettime() - time1) *1000
DebugNote("Time to find mob is ".. time2)
  if roomNumber ~= nil and nameHolder ~=nil then
    DebugNote ("check")
    --tprint (cp_mobs)
    DebugNote(cp_mobs[tableNum].num)
    DebugNote ("///check")
    makeTable(tonumber(roomNumber), nameHolder, cp_mobs[tableNum].mobdead, true, loc, cp_mobs[tableNum].num)
    mob_index= 1
  end--if
  if roomNumber == nil then
    DebugNote("here")
    makeTable(loc, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, false, loc, cp_mobs[tableNum].num)
    mob_index= 1
  end--if

end

function getRoomIdRoomCP(name, nameHolder, tableNum)-- TODO some bug here where it drops the last 2 things in list
local loc = cp_mobs[tableNum].location
local mob_table_name= ''
local rows_counter= 1
local rows_counter_check= 0
local databasetest = dbA
local databasekt = dbkt --dbkt assigner
local make1 = makeTable
local make2 = makeTable2
local call = CallPlugin
local DebugNote = DebugNote
local findmob_table= {}
local area_table= {}
local strbld = string.format
local room_num_table= room_num_table
local room_num_table2= room_num_table2
local tableNum = tonumber(tableNum)
local levelAdj = 11
local found = 0
local areaName
-- Note(name.."")
 res, gmcparg = call("3e7dedbe37e44942dd46d264","gmcpval","char") --- We just want the gmcp.char section.
 luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.
 assert (loadstring (luastmt or "")) ()
 level = tonumber(gmcpdata.status.level) -- uncomment for live
 if GQ_flag then levelAdj = 22 end
 --level = 70 -- for testing
 min_level = level - levelAdj 
 max_level = level + levelAdj

 if (min_level<0)then min_level=0 end
 --print (min_level.." ".. max_level)   
--  findmob = string.format("select room_id, COUNT(*) as timeskilled,"..
--           " name from mobkills "..
--           "where name = %s "..
--           "ORDER by timeskilled DESC ", fixsql(name))
-- for rows in databasekt:nrows(findmob) do
--   print (i)
--   tprint(rows)
--   findmob_table[i]= rows
--   i = i+1
-- end--for
--  tprint (findmob_table)
-- for ind, val in ipairs(findmob_table) do

-- end--for
    local queryCount = strbld("select COUNT(*) as counter"..
      " from rooms, areas"..
      " where areas.uid = rooms.area and rooms.name = %s",fixsql(cp_mobs[tableNum].location))
    local query1 = strbld("select rooms.uid as roomuid,"..
      " areas.name as areaName,"..
      " rooms.name as roomName"..
      " from rooms rooms, areas"..
      " where areas.uid = rooms.area and rooms.name = %s",fixsql(cp_mobs[tableNum].location))
    local  cpmobquery = string.format("select room_id, area_name, name, COUNT(*) as timeskilled "..
        "from CPMobs "..
        "where name like %s and "..
        "room_name = %s"..
        "group by room_id, name "..
        "ORDER by timeskilled desc ", fixsql(name), fixsql(loc))
    
    for rows in databasekt:nrows(cpmobquery) do
      roomNumber = rows.room_id
      areaName = rows.area_name
      found = 1
    end
    if found == 1 then 
      found = 0
      DebugNote("found it in the cp_mobs table 001")
      make1(roomNumber, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, true, areaName, cp_mobs[tableNum].num)
      return
    end
    
    for rows in databasetest:nrows(queryCount) do
      rows_counter = rows.counter
    end--for
   -- print ("")
    -- print ("rows_counter = "..rows_counter)
    for rows in databasetest:nrows(query1) do
                --print ("")

               
      rows_counter_check = rows_counter_check+1
      --print ("rows_counter_check = " ..rows_counter_check)
     -- tprint(rows)
      area_table[rows_counter_check] = rows

      end--for

--DebugNote(area_table)
    local area_table_size = #area_table
    --tprint(area_table)
    for z=1, area_table_size do
      -- print ("")
      -- print("val")
     --DebugNote(area_table)
      -- print("")
--         query = strbld("select room_id, COUNT(*) as timeskilled,"..
--           " name from mobkills "..
--           "where room_id = %s "..
--           "and name = %s "..
--           "group by room_id, name "..
--           "ORDER by timeskilled ASC ", fixsql(area_table[z].uid), fixsql(name))
--         for a in databasekt:nrows(query) do   
-- --print(dbkt:errmsg())
--         -- print("")
--         -- print("a from mobkills")
--          tprint (a)   
--         -- print("") 
--           roomTemp= a.room_id
--           --if string.lower(a.name) == string.lower(name) then--or cp_mobs[tableNum].location == rows.roomName not sure if this one was needed
--             roomNumber= roomTemp
--             mob_table_name = a.name
--             --print(rows.roomName)
--             --print(a.name.. " got here....................................... breaking")
--             -- break       
--           --end --if

--         end--for
      roomNumber= tonumber(area_table[z].roomuid)

      --print ("checking timming")
      --for a, v in ipairs(areaLevel) do
       -- print (rows.name)
        --if rows.areaName == v.name then
          --if v.minLevel ~=nil and v.maxLevel ~=nil then
          -- print ("area_table[z].areaName "..area_table[z].areaName)
          -- print ("areaLevel[area_table[z].areaName].minLevel "..areaLevel[area_table[z].areaName].minLevel)
          -- print ("max_level "..max_level)
          -- print("areaLevel[area_table[z].areaName].maxLevel "..areaLevel[area_table[z].areaName].maxLevel)
          -- print("min_level "..min_level)
          
            if areaLevel[area_table[z].areaName].minLevel > max_level or areaLevel[area_table[z].areaName].maxLevel<min_level then -------- testing with and was or
              -- print ("rejected")
              -- print ("")
              -- print (area_table[z].areaName)
              --Note("area out of level range")
              rows_counter= rows_counter-1
              rows_counter_check = rows_counter_check-1
              --break
            else
              -- print ("accepted")
              -- print ("")
              local foundone_room_table2 = false
              local foundone_room_table = false
               -- print ("tableNumHolder = "..tostring(tableNumHolder)..' '.. type(tableNumHolder))
               --    print ("tableNum = "..tostring(tableNum)..' '.. type(tableNum))
              if room_num_table ~= nil and #room_num_table >0 then
                for p= 1, #room_num_table do
                  if (string.lower(room_num_table[p][2]) == string.lower(nameHolder) or room_num_table[p][1]== area_table[z].uid)
                    and tableNum== tableNumHolder then foundone_room_table= true  end--if-- cp_mobs[tableNum].name
                end--for
              end--if
              if #room_num_table2 > 0 and room_num_table2 ~= nil then
                -- print ("test")
                --tprint (area_table)
                for i= 1, #room_num_table2 do
                          -- print (area_table[z].areaName) print(  room_num_table2[i][5])
                          -- print (room_num_table2[i][1]) print( area_table[z].roomuid)
                          -- print (room_num_table2[i][2]) print( cp_mobs[tableNum].name)
                  if area_table[z].areaName == room_num_table2[i][5] or room_num_table2[i][1]== area_table[z].roomuid  then-- see if the first condition needs and tableNum == tableNumHolder
                 
                    foundone_room_table2 = true
                    break
                  else
                    foundone_room_table2 = false
                  end--if
                end--for
              end--if
            
              if not foundone_room_table then
                -- print ("added table 1 ".. area_table[z].areaName .. " " .. cp_mobs[tableNum].name)
                make1(roomNumber, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, true, area_table[z].areaName, cp_mobs[tableNum].num)
                tableNumHolder= tonumber(tableNum)
                mob_index= 1
              elseif not foundone_room_table2 then
                -- print ("added table 2 ".. area_table[z].areaName .. " " .. cp_mobs[tableNum].name)
                make2(roomNumber, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, true, area_table[z].areaName, cp_mobs[tableNum].num)
                mob_index= 1
              end--if

              -- if room_num_table ~= nil and #room_num_table > 0 then
                -- for i=1, #room_num_table do
                --   --print ((string.lower(room_num_table[i][2]) == string.lower(nameHolder) or room_num_table[i][1]== area_table[z].uid))
                --   if ((string.lower(room_num_table[i][2]) == string.lower(nameHolder) or room_num_table[i][1]== area_table[z].uid)) then-- see if the first condition needs and tableNum == tableNumHolder
                    
                --     local foundone = false
                --     --if room_num_table2 ~= nil and #room_num_table2>0 then
                --       for i= 1, #room_num_table2 do
                        
                --         if (area_table[z].areaName == room_num_table2[i][5] or room_num_table2[i][1]== area_table[z].uid) then-- see if the first condition needs and tableNum == tableNumHolder
                --         --print ("tableNumHolder = "..tableNumHolder)
                --         --print ("tableNum = "..tableNum)
                --         foundone = true
                        
                --         end--if
                --       end--for
                --     --end--if
                --     if foundone == false or room_num_table2 == nil then
                --       make2(tonumber(area_table[z].uid), cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead,false, area_table[z].areaName)
                --       mob_index= 1
                --     end
                --     found = false
                --       break
                --   end--if
                --     -- print ("added ".. area_table[z].areaName)
                --     -- make1(roomNumber, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, true, area_table[z].areaName)
                --     -- mob_index= 1
                --     -- break
                -- end--for
              -- end--if
            end--if
                 -- if mob_table_name~= '' then
                 -- print ("added ".. area_table[z].areaName)
                 --  make1(roomNumber, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, true, area_table[z].areaName)
                 --  mob_index= 1
                 --  break
                -- end--if for the commented section below
            --print ("what")
          --end--if
          --print ("the")
       -- end--if
      --end--for
       --Note("Not found or not open, trying something else")
    end--for
  -- DebugNote ("rows_counter end = "..rows_counter)   
   --DebugNote ("rows_counter_check = " .. rows_counter_check)
  -- if rows_counter_check == rows_counter then
  --   make1(-1, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, false)
  --   --print ('-1 becuase check = counter')
  -- end--if
  -- print ("------------------------------------Next Check done")
  tableNumHolder= tonumber(tableNum)
  --tprint (area_table)
  mob_index= 1
end
-- This section is almost a straight rip from Fiendish's aard_GMCP_mapper.xml all credit goes to him
local bit = require("bit")
function load_room_from_database (uid)
   local room
   local u = tostring(uid)
   assert (uid, "No UID supplied to load_room_from_database")

   -- if not in database, don't look again
   if room_not_in_database [u] then
      return nil
   end -- no point looking

   for row in dbnrowsWRAPPER(string.format ("SELECT * FROM rooms WHERE uid = %s", fixsql (u))) do
      room = {
         name = row.name,
         area = row.area,
         building = row.building,
         terrain = row.terrain,
         info = row.info,
         notes = row.notes,
         x = row.x or 0,
         y = row.y or 0,
         z = row.z or 0,
         noportal = row.noportal,
         norecall = row.norecall,
         exits = {},
         exit_locks = {},
         ignore_exits_mismatch = (row.ignore_exits_mismatch == 1)
      }

      for exitrow in dbnrowsWRAPPER(string.format ("SELECT * FROM exits WHERE fromuid = %s", fixsql (u))) do
         room.exits [exitrow.dir] = tostring (exitrow.touid)
         room.exit_locks [exitrow.dir] = tostring(exitrow.level)
      end -- for each exit

   end   -- finding room

   if room then
      if not rooms then
         -- this shouldn't even be possible. what the hell.
         rooms = {}
      end
      rooms [u] = room
      for row in dbnrowsWRAPPER(string.format ("SELECT * FROM bookmarks WHERE uid = %s", fixsql (u))) do
         rooms [u].notes = row.notes
      end   -- finding room

      return room
   end -- if found

   -- room not found in database
   room_not_in_database [u] = true
   return nil

end -- load_room_from_database
forced_opened = false
force_nests = 0
function forceOpenDB()
   force_nests = force_nests+1
   if not db:isopen() then
      forced_opened = true
      -- print("Forcing open")
      db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
   end
end
function dbnrowsWRAPPER(query)
   forceOpenDB()
   iter,vm,i = db:nrows(query)
   local function itwrap(vm, i)
      retval = iter(vm, i)
      if not retval then
         closeDBifForcedOpen()
         return nil
      end
      return retval
   end
   return itwrap,vm,i
end
function closeDBifForcedOpen()
   force_nests = force_nests-1
   if forced_opened and (force_nests <= 0) then
      force_nests = 0
      forced_opened = false
      -- print("Forcing closed")
      db:close()
   end
end
function findNearestJumpRoom(src, dst, target_type)
   local depth = 0
   local max_depth = 500
   local room_sets = {}
   local rooms_list = {}
   local found = false
   local ftd = {}
   local destination = ""
   local next_room = 0
   local visited = ""
   local path_type = ""

   table.insert(rooms_list, fixsql(src))
   --local main_status = GetInfo(53)
   while not found and depth < max_depth do
      --SetStatus(main_status.." (searching jump depth "..depth..")")
     -- BroadcastPlugin (999, "repaint")
      depth = depth + 1

      -- prune the search space
      if visited ~= "" then
         visited = visited..","..table.concat(rooms_list, ",")
      else
         visited = table.concat(rooms_list, ",")
      end

      -- get all exits to any room in the previous set
      local q = string.format ("select fromuid, touid, dir, norecall, noportal from exits,rooms where rooms.uid = exits.touid and exits.fromuid in (%s) and exits.touid not in (%s) and exits.level <= %s order by length(exits.dir) asc",
                  table.concat(rooms_list,","), visited, mylevel)
      local dcount = 0
      for row in dbnrowsWRAPPER(q) do
         dcount = dcount + 1
         table.insert(rooms_list, fixsql(row.touid))
         -- ordering by length(dir) ensures that custom exits (always longer than 1 char) get
         -- used preferentially to normal ones (1 char)
         if ((bounce_portal ~= nil or target_type == "*") and row.noportal ~= 1) or ((bounce_recall ~= nil or target_type == "**") and row.norecall ~= 1) or row.touid == dst then
            path_type = ((row.touid == dst) and 1) or ( (((row.noportal == 1) and 2) or 0) + (((row.norecall == 1) and 4) or 0) )
            -- path_type 1 means walking to the destination is closer than bouncing
            -- path_type 2 means the bounce room allows recalling but not portalling
            -- path_type 4 means the bounce room allows portalling but not recalling
            -- path_type 0 means the bounce room allows both portalling and recalling
            destination = row.touid
            found = true
            found_depth = depth
         end -- if src
      end -- for select

      if dcount == 0 then
         return -- there is no path to a portalable or recallable room
      end -- if dcount
   end -- while

   if found == false then
      return
   end
   return destination, path_type, found_depth
end
function findpath(src, dst, noportals, norecalls)
  -- print(src)
  -- print(dst)
   if not rooms[src] then
      rooms[src] = load_room_from_database(src)
   end
   if not rooms[src] then
    -- print('did I return?')
      return
   end

   local walk_one = nil
   -- tprint(rooms[src])
   for dir,touid in pairs(rooms[src].exits) do
      if tostring(touid) == tostring(dst) and tonumber(rooms[src].exit_locks[dir]) <= mylevel and ((walk_one == nil) or (#dir > #walk_one)) then
         walk_one = dir -- if one room away, walk there (don't portal), but prefer a cexit
         -- print('was I one room away?')
      end
   end
      if walk_one ~= nil then
      return {{dir=walk_one, uid=touid}}, 1
   end
   local depth = 0
   local max_depth = 500
   local room_sets = {}
   local rooms_list = {}
   local found = false
   local ftd = {}
   local f = ""
   local next_room = 0 
   if type(src) ~= "number" then
      src = string.match(src, "^(nomap_.+)$") or tonumber(src)
   end
   if type(dst) ~= "number" then
      dst = string.match(dst, "^(nomap_.+)$") or tonumber(dst)
   end

   if src == dst or src == nil or dst == nil then
      return {}
   end

   src = tostring(src)
   dst = tostring(dst)

   table.insert(rooms_list, fixsql(dst))

   local visited = ""
   --local main_status = GetInfo(53)
   while not found and depth < max_depth do
      --SetStatus(main_status.." (searching depth "..depth..")")
      --BroadcastPlugin (999, "repaint")
      depth = depth + 1
      if depth > 1 then
         ftd = room_sets[depth-1] or {}
         rooms_list = {}
         for k,v in pairs(ftd) do
            table.insert(rooms_list, fixsql(v.fromuid))
         end -- for from, to, dir
      end -- if depth

      -- prune the search space
      if visited ~= "" then
         visited = visited..","..table.concat(rooms_list, ",")
      else
         if noportals then
            visited = visited..fixsql("*")..","
         end
         if norecalls then
            visited = visited..fixsql("**")..","
         end
         visited = visited..table.concat(rooms_list, ",")
      end

      -- get all exits to any room in the previous set
      local q = string.format ("select fromuid, touid, dir from exits where touid in (%s) and fromuid not in (%s) and ((fromuid not in ('*','**') and level <= %s) or (fromuid in ('*','**') and level <= %s)) order by length(dir) asc",table.concat(rooms_list,","), visited,mylevel,mylevel+(mytier*10))
      local dcount = 0
      room_sets[depth] = {}
      for row in dbnrowsWRAPPER(q) do
       
         dcount = dcount + 1
         -- ordering by length(dir) ensures that custom exits (always longer than 1 char) get
         -- used preferentially to normal ones (1 char)
         room_sets[depth][row.fromuid] = {fromuid=row.fromuid, touid=row.touid, dir=row.dir}
         if row.fromuid == "*" or (row.fromuid == "**" and f ~= "*" and f ~= src) or row.fromuid == src then
            f = row.fromuid
            found = true
            found_depth = depth
         end -- if src
      end -- for select

      if dcount == 0 then
         return -- there is no path from here to there
      end -- if dcount
   end -- while

   if found == false then
      return
   end

   -- We've gotten back to the starting room from our destination. Now reconstruct the path.
   local path = {}
   -- set ftd to the first from,to,dir set where from was either our start room or * or **
   ftd = room_sets[found_depth][f]

   if (f == "*" and rooms[src].noportal == 1) or (f == "**" and rooms[src].norecall == 1) then
      if rooms[src].norecall ~= 1 and bounce_recall ~= nil then
         table.insert(path, bounce_recall)
         if dst == bounce_recall.uid then
            return path, found_depth
         end
      elseif rooms[src].noportal ~= 1 and bounce_portal ~= nil then
         table.insert(path, bounce_portal)
         if dst == bounce_portal.uid then
            return path, found_depth
         end
      else
         local jump_room, path_type = findNearestJumpRoom(src, dst, f)
         if not jump_room then
            return
         end
         local path, first_depth = findpath(src,jump_room, true, true) -- this could be optimized away by building the path in findNearestJumpRoom, but the gain would be negligible
         if bit.band(path_type, 1) ~= 0 then
            -- path_type 1 means just walk to the destination
            return path, first_depth
         else
            local second_path, second_depth = findpath(jump_room, dst)
            for i,v in ipairs(second_path) do
               table.insert(path, v) -- bug on this line if path is nil?
            end
            return path, first_depth+second_depth
         end
      end
   end

   table.insert(path, {dir=ftd.dir, uid=ftd.touid})

   next_room = ftd.touid
   while depth > 1 do
      depth = depth - 1
      ftd = room_sets[depth][next_room]
      next_room = ftd.touid
-- this caching is probably not noticeably useful, so disable it for now
--      if not rooms[ftd.touid] then -- if not in memory yet, get it
--         rooms[ftd.touid] = load_room_from_database (ftd.touid)
--      end
      table.insert(path, {dir=ftd.dir, uid=ftd.touid})
   end -- while
   return path, found_depth
end -- function findpath
-- end section of Fienish's work
require 'aardmapper'

function sortRoomCPByPath()
  local x
  dist_tbl = {}
  -- print(room_num_table[1][1])
  --print(currentRoom.roomid)
  --print(type(currentRoom.roomid))
  if currentRoom.roomid == '-1'   then
    print('if you would like the mobs to be sorted by distance move out of unmappable rooms then type cp check again')
    return
  end
  --print(currentRoom.roomid)
  for i, p in ipairs(room_num_table) do
    --print(i)
    
    x, dep = findpath(currentRoom.roomid,p[1])
    --print (dep)
    if dep ~= nil then
      table.insert(dist_tbl, { i, dep })
    else 
      table.insert(dist_tbl, {i, 501})
    end--if
  end
  local keys = {}
  local b = {}
  local q = {}
  for k in pairs(dist_tbl) do table.insert(keys, k) end
  --tprint(keys)
  table.sort(keys, function(a, b) return dist_tbl[a][2] < dist_tbl[b][2] end)
  for _, k in ipairs(keys) do 
    --print(k)
    --print(k,dist_tbl[k][1], dist_tbl[k][2]) 
    table.insert(b, cp_mobs[k])
    table.insert(q, room_num_table[k])
  end
  room_num_table = q
  cp_mobs = b
  closeDBifForcedOpen()
  
end
function sortRoomCP()
  cnt = 0
  --tprint(room_num_table)
  local sort_func = function( a,b ) return a[5] < b[5] end
  --local sort_func1 = function( a,b ) return a.name == room_num_table[2] end
  -- DebugNote("\nBEGIN ROOMNUM CHECN")
  -- DebugNote(room_num_table)
  -- DebugNote("\n")
  table.sort( room_num_table, sort_func )
  -- DebugNote(room_num_table)
  -- DebugNote("END ROOMNUM CHECN\n")
  
  local function findi (t, a)
    -- DebugNote(a)
    for i, n in ipairs(t) do

      if string.lower(n.name) == string.lower(a) then 
        -- DebugNote(n.name) 
        cnt = cnt+1
      -- DebugNote(a)
       return cnt, i end
    end
  end
  b = {}
  for i, n in pairs(room_num_table) do 
        -- DebugNote(n)
        -- DebugNote("\nNew entery")
        -- DebugNote(room_num_table[i][2])
    local cnt,  num = findi(cp_mobs, room_num_table[i][2])
    -- DebugNote("count " .. cnt)
    -- DebugNote(num)
    if num == nil then tprint (cp_mobs) end
        -- DebugNote(num)
        -- DebugNote(cp_mobs[num])
    table.insert(b, cp_mobs[num])
        -- DebugNote("\n Deleting\n")
        -- DebugNote(cp_mobs[num])
        -- DebugNote("End Deleting\n")
    table.remove(cp_mobs, num) 
        -- DebugNote(i.." left in the table ".. #cp_mobs)
  end
  -- DebugNote(cp_mobs)
  -- DebugNote(b)
  cp_mobs = b
end
mob_index= tonumber(1)
mob_next_delete_value= nil

function do_Execute_no_echo(command)
  local original_echo_setting = GetOption("display_my_input")
  SetOption("display_my_input", 0)
  Execute(command)
  SetOption("display_my_input", original_echo_setting)
end

function gotoNextMob()-- This will goto the next mob, use with tcp
  if cp_mobs == nil then
    print ('Nothing to go to!')
    return 
  end
  if mob_index == nil then
    mob_index=1
  end--if
  if room_num_table == nil or #room_num_table<1 then
    return
  end--if
  if room_num_table[1][1] == -1 then
    print ("Try tcpo or manually finding this mob.. use pto to check the other table")
    return
  end--if
  check_dead()
  if room_num_table[1][3] == false then
    if hunt_type(0, 0) == 1 then
      return
    end--if
 
    Execute('xmapper1 move '..  getTable(mob_index))
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(mob_index)
    mob_next_delete_value= mob_index
    Send("sca ".. mobname)
  else
    if hunt_type(0, 1) == 1 then
      return
    end--if
    Execute('xmapper1 move '..  getTable(mob_index+1))
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(mob_index+1)
    mob_next_delete_value= mob_index+1
    Send("sca ".. mobname)
  end--if
end

function gotoIndexMob(name, line, wildcards)-- This will goto the next mob, use with tcp
 
  wild= tonumber(wildcards[1])
  if wild == nil then return end
  if cp_mobs == nil then
    print("Nothing to goto.")
    return 
  end
  if tonumber(wildcards[1])<0 or tonumber(wildcards[1])> #room_num_table then
    return
  end
  if room_num_table == nil then
    return
  end--if
    if room_num_table[wild][1] == -1 then
    print ("Try tcpo or manually finding this mob.. use pto to check the other table")
    return
  end--if
  check_diff()
  check_dead()
    if hunt_type(wild, 0) == 1 then
      return
    end--if
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(wild)
    mob_next_delete_value= wild
    Execute('xmapper1 move '..  getTable(tonumber(wildcards[1])))
    Send("sca ".. mobname)
end
function tcpohandler(name, line, wildcards)
  if wildcards[1] ~= nil then
    if room_num_table2 == nil or tonumber(wildcards[1])>#room_num_table2 then
     return
    end--if
  end--if

  if #wildcards>=1 then
     mobname = sanitizeName(room_num_table2[tonumber(wildcards[1])][2])
    Execute ('xmapper1 move '.. room_num_table2[tonumber(wildcards[1])][1])
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(wildcards[1])
    mob_next_delete_value= wildcards[1]
    Send("sca ".. mobname)
  else
    mobname = sanitizeName(room_num_table2[1][2])
    Execute ('xmapper1 move '.. room_num_table2[1][1])
    mob_next_delete_value= 1
    Send("sca ".. mobname)
  end--if
end

function hunt_type (num, mob_id)
  if mob_index == 0 then
    local mob_index = 1
  else
    local mob_index = 2
  end--if
  if num ~= 0 then
    if type(room_num_table[tonumber(num)][1])== 'string' then -- If An index query and room type
      DebugNote("Entry for mob_next_delete_value")
    DebugNote(num)
      mob_next_delete_value= tonumber(num)
      holder= getTable(num)  
      if ((string.find(string.lower(room_num_table[num][1]), currentRoom.areaid))) then
        print('well this is awkward you are already in the correct area')
      else
        Execute('xrunto1 '..room_num_table[num][1])
      end--if
      cpn_script(tonumber(num))
      
      return 1
    end--if
  else
    if type(room_num_table[mob_index][1])== 'string' then-- if NOT an indexed query and a room type
      DebugNote("Entry for mob_next_delete_value")
    DebugNote(mob_index)
    mob_next_delete_value= mob_index
    holder= getTable(mob_index)
    if (( string.find(string.lower(room_num_table[mob_index][1]), currentRoom.areaid))) then
      print('well this is awkward you are in the correct area')
    else
      Execute('xrunto1 '..room_num_table[mob_index][1])
    end--if
    cpn_script(mob_index)
      
      return 1      
    end--if
  end--if
end

where_mob= ''

function whereMob(name, line, wildcards)
  where_mob= wildcards[1]
  if where_mob==nil then
     if mobname ~= nil then
      EnableTrigger('where_mob_trig', true)
      Execute('where '.. mobname)

      DoAfterSpecial(2, "EnableTrigger('where_mob_trig', false)", 12)
    else
      print ("Need to use tcp or tcp <index> first")
      return
    end --if
  else
    EnableTrigger('where_mob_trig', true)
    Execute('where '.. where_mob)
    DoAfterSpecial(1, "EnableTrigger('where_mob_trig', false)", 12)
    where_mob = string.gsub(where_mob,"%d+%.","")
    mobname =  where_mob
  end--if
end

local where_black_list = {"Your magic is blessed with",
"You feel less righteous as the",
"You now possess magical powers",
"You feel gills growing on your",
"You now detect the presence of"}
function where_mob_trig(name, line, wildcards)
   -- SetVariable("test","test ="..serialize.save_simple(where_black_list))
   -- assert (loadstring (GetVariable ("test") or "")) ()
  for i,p in ipairs(where_black_list) do
    if (string.find( wildcards[0], p) ~= nil) then
     -- print ("true")
      return
    end--if
  end--for
    wildcards[1], x = string.gsub(wildcards[1],"%.","")
  bool = 0
  --print(bool)
  for word in mobname:gmatch("%w+") do
  if (string.find( string.lower(wildcards[1]), string.lower(word)) ~= nil) then 
    bool =1
  end--if
  print(bool)
  end -- for
  if bool == 1 then
    Execute('mapper area '.. '"'..wildcards[2]..'"')
    Execute('mapper next')
    EnableTrigger('where_mob_trig', false)
  end--if
end

function killMob()
  if mobname ~= nil then
    Execute("kill ".. mobname)
  else
    print ("Need to use aknx or aknx <index> first")
  end --if
end

function fixsql (s)
   if s then
      return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
   else
      return "NULL"
   end -- if
end -- fixsql

areaLevel= {}

-- In case of a mob not in the db then these will get used

count = 1
function incrementCounter()
count = count + 1
Execute("hunt ".. count..".".. mobname)
end

function reset_counter()
 count=1
end
CPMobs= {}
CPMobs1= {}
CPMobsIndex= 1
vnum_holder= 0
function reset_index()
 CPMobsIndex = 1
 CPMobs1= {}
end

cpn_is_room_type= false
cpn_is_room_type_table = {}
cpnrtt = 1



function hunt_from_link( area)
  DebugNote (area)
  Execute("xrunto1 ".. area)
  Execute ("hunt " .. mobname)
end

dbA= nil
dbkt= nil
rooms = {1, 1}
areas = {}
mobktbl = {}
function StartScript()
  print("here")
  do_Execute_no_echo('map')

  do_Execute_no_echo("cp check")
  

  db=sqlite3.open(GetInfo (66) ..'\\logs\\aardinfo.db')
  query= "select keyword, name, afrom, ato, alock from areas"
  rc =db:exec(query)
  if rc ~= 0 then 
    db:close()
    os.remove(GetInfo (66) .."\\logs\\aardinfo.db")
    os.rename(GetPluginInfo (GetPluginID (), 20) .."aardinfo.db", GetInfo (66) .."\\logs\\aardinfo.db")
    db=sqlite3.open(GetInfo (66) ..'\\logs\\aardinfo.db')
    
  end
  local v =tonumber(0)
  for a in db:nrows(query) do
    areaLevel[a.name]= {}
    areaLevel[a.name].keyword= a.keyword
    areaLevel[a.name].name = a.name
    areaLevel[a.name].minLevel= a.afrom
    areaLevel[a.name].maxLevel= a.ato
    areaLevel[a.name].lock = a.alock or ''
    v = v +1
  end-- for
  v = 0
  db:close()
  dbA=sqlite3.open(GetInfo (66) ..'Aardwolf.db')
  print (GetPluginInfo (GetPluginID (), 20))
  dbkt=sqlite3.open(GetPluginInfo (GetPluginID (), 20) .. 'KillTable.db')
  dbkt:busy_handler(myHandler)
  --testtable = {}
  --time =socket.gettime()
  qry= "select * from rooms where uid not like '*' and uid not like '**' order by uid"
  qry2 = "select * from areas"
  qry3 = "select *, count(*) as timeskilled from mobkills group by room_id order by name, timeskilled desc"
  c= 0
  rooms = {}
  
  for row in dbA:nrows(qry) do
    
    rooms[row.uid]= {} 
      c = c+1
    
    rooms[row.uid] = {
    name = row.name,
    area = row.area,
    terrain = row.terrain,
    info = row.info,
     noportal = row.noportal,
     norecall = row.norecall,
     ignore_exits_mismatch = (row.ignore_exits_mismatch == 1),
     exits = {},
     exit_locks = {}
    }
  
  end
  for row in dbA:nrows(qry2) do
    areas[row.uid] = {
      name = row.name
  }
  end
 -- c = 0
  for row in dbkt:nrows(qry3) do
   c = c+1
    --DebugNote("Inserting " .. row.name .. " Room ".. row.room_id .. " TimesKilled " .. row.timeskilled)
    mobktbl[c] = {
      name = row.name,
      room_id =row.room_id,
      timeskilled = row.timeskilled
  }
  --DebugNote("Data: " .. mobktbl[c].name .. " Room: " .. mobktbl[c].room_id .. " TimesKilled: " .. mobktbl[c].timeskilled)
  end -- end of for loop? lol, whoops ok  lets do it

  --tprint(areas['deathtrap'])
  --print (c)
  --time2 = (socket.gettime()- time)*1000
  --print (time2)
  -- time = socket.gettime()
  -- rooms = {}
  --     time2 = socket.gettime() *1000
      --print (time2)
      --tprint (rooms['30786'])
     -- c = 0
      
      for i,v in pairs(rooms) do
        c =c +1
      end
      --print (c)
      --tprint(testtable[c-1])
  rc =dbkt:exec([[SELECT name, room_id FROM mobkills ]])
  if rc~= 0 then
    init()
    print ('making table')
  end--if
   assert (loadstring (GetVariable ("greedy") or "")) ()
   print (greedy)
   --LoadPlugin()
   --Note(tostring(IsPluginInstalled("0961770926b613688a1c5458")).. " cp_mobTableFiller")
   --Note(tostring(IsPluginInstalled("eee3a98a021c1bee534ef09f")).. " minwin")
  if not IsPluginInstalled("0961770926b613688a1c5458") then
    LoadPlugin(GetPluginInfo (GetPluginID (), 20) .. "cp_mobTableFiller.xml")
  end
  if not IsPluginInstalled("eee3a98a021c1bee534ef09f") then
    LoadPlugin(GetPluginInfo (GetPluginID (), 20) .. "TOLminwin.xml")
  end
  dbA:close()
end
local didonce = false
function OnPluginInstall()
  if IsConnected() and started == true and didonce == false then
    StartScript()
    print("start")
    didonce = true
    started = true
  end
end
function myHandler(udata, retries)
   DebugNote("BUSY!")
   return true
end
function OnPluginClose ()
    --dbA:close()
    dbkt:close()
end

function reset_cp_flag( )
  timeEnd()
  FirstRun_cp_var= true
end

function collectgarbagenow()
 Note( collectgarbage("count")*1024)
  collectgarbage("collect")
  Note( collectgarbage("count")*1024)
end

function DebugNote( msg )
  if not Debug then return end
    if type(msg)== 'table' then
      tprint(msg)
    else
      Note (msg)
    end
  
end
-- This whole block is ripped directly from Winkle's plugin, all credit to him.
---//////////////////////////////////////////////////////////////////////////////////////////////////
--////////////////                                    |\     |          ^
--///////////////                                     | \    |        /   \
--//////////////                                      |  \   |       /     \
--/////////////                                       |   \  |      <       >
--////////////                                        |    \ |       \     /
--///////////                                         |     \|        \   /
--//////////                                          |      |          v
--///////////////////////////////////////////////////////////////////////////////////////////////////
local xrun_to_sql1 =  
    "SELECT r.uid, r.name as room, a.name as area " ..
    "FROM rooms r " ..
    "INNER JOIN areas a ON a.uid = r.area " ..
    "WHERE a.uid like %s " ..
    "ORDER BY r.uid "
    
  local xrun_to_sql2 =  
    "SELECT r.uid, r.name as room, a.name as area " ..
    "FROM rooms r " ..
    "INNER JOIN areas a ON a.uid = r.area " ..
    "WHERE a.uid like %s " ..
    "OR a.name like %s " ..
    "ORDER BY r.uid "

    local xrun_to_sql_FR = 
      " SELECT b.uid, b.notes "..
      " FROM bookmarks b "..
      " INNER JOIN rooms r on r.uid = b.uid "..
      " WHERE r.area like %s " ..
      " AND b.notes = 'Tstart' "

  function xrun_to1(name, line, wildcards)
    local index1 = 1
    local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
    local db = assert(sqlite3.open(worldPath .. ".db"))
    db:busy_handler(myHandler)

    -- HACK for ftii
    if (wildcards[1] == "ft2") then
      wildcards[1] = "ftii"
    end
    local like = fixsql("%" .. wildcards[1] .. "%")
    -- try exact hit first
    local select1 = string.format (xrun_to_sql1, fixsql(wildcards[1]))
    DebugNote("xrun_to (1)- " .. select1)
    local select2 = string.format (xrun_to_sql_FR, like)
    DebugNote("xrun_to (1)- " .. select2)
    for row in db:nrows(select2) do 
      DebugNote(row)
      goto_roomid(row.uid)
      index1 = index1 +1
      db:close()
      return
    end
    
    --Note(string.format (sql, fixsql(wildcards[1])))
    for row in db:nrows(select1) do

      ColourNote("darkorange", "", "x-runto (" .. row.uid .. ") " .. row.room .. " in " .. row.area)
      goto_roomid(row.uid)
      
      index1 = index1 + 1
      db:close()
      return
    end
    

    
    select1 = string.format (xrun_to_sql2, like, like)
    DebugNote("xrun_to (2)- " .. select1)

    for row in db:nrows(select1) do
      ColourNote("darkorange", "", "x-runto (" .. row.uid .. ") " .. row.room .. " in " .. row.area)
      goto_roomid(row.uid)
      
      index1 = index1 + 1
      db:close()
      return
    end

    if (index1 == 1) then

      ColourNote("darkorange", "", "No matching rooms found. Using aardwolf runto...")
      Execute("xmapper1 move 32418") -- recall
      Execute("runto " .. wildcards[1])
    end
    db:close()
  end

  function goto_roomid(roomid)

    --local dest_in_vidblain = is_vidblain_area(roomid)
    --tprint(currentRoom)
   -- local both_in_vidblain = dest_in_vidblain and is_vidblain_area(currentRoom.roomid)


    -- if (dest_in_vidblain == true and both_in_vidblain == false) then
    --   Execute("xmapper1 move 11910")
    --   Execute("enter hole")

    --   local func = function() Execute("xmapper1 move " ..  roomid) end
    --   execute_in_area("vidblain_hack", "vidblain", func)

    -- else

    --print ('skipped the vidblain stuff')
      Execute("xmapper1 move " .. roomid)
    --end
  end

  -- local is_vidblain_area_sql =  
  --   "SELECT area " ..
  --   "FROM rooms " ..
  --   "WHERE uid = %s "

  -- function is_vidblain_area(roomid)

  --   if (USER_check_vidblain == "false") then
  --     return false
  --   end

  --   local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
  --   local db = assert(sqlite3.open(worldPath .. ".db"))

  --   local select = string.format (is_vidblain_area_sql, fixsql(roomid))
  --   for row in db:nrows(select) do
  --     --Note(row.area)
  --     local areaid = row.area
  --     if (areaid == "vidblain" or
  --       areaid == "imperial" or
  --       areaid == "darklight" or
  --       areaid == "sendhian" or
  --       areaid == "omentor") then
        
        
  --       return true
  --     end
  --   end   
    

  --   return false

  -- end
  local execute_in_area_array = {}

  function execute_in_area(id, areaId, functionPointer)

    execute_in_area_array[id] = { 
      areaId = areaId, 
      func = functionPointer, 
      index = 0, 
      active = true,
      lastState = 3, -- standing
      standIndex = 0 -- count of stands in a row
      }
    --tprint(execute_in_area_array)
    EnableTimer("execute_in_area_timer", true)

  end

  function execute_in_area_tick(name, line, wildcards)

    local localRoom = currentRoom
    local localState


    -- thread safety
    if (localRoom == nil) then
    --  DebugNote("Unknown Room")
      return
    end
    
    if (char_status == nill) then
   --   DebugNote("Unknown char status")
      return
    else
      localState = tonumber(char_status.state)
    end

    local isActive = false
    
    --tprint(execute_in_area_array)

    for index, value in pairs(execute_in_area_array) do
      --tprint(execute_in_area_array)
     -- DebugNote("loop - " .. index)
      if (value.active == true) then
    
        value.index = value.index + 1

        if (value.index > 100) then
          value.active = false
          print("** aborting quickwhere timer for " .. index1 .. ", took too long to get to destination")
          
        else

         -- DebugNote("state:" .. localState .. ",:" .. value.areaId .. "==" .. localRoom.areaid)

          if ((localState == 3 and value.lastState == 3) 
            and value.areaId == localRoom.areaid) then

            -- skip first timer tick
            value.index = value.index + 1
            value.standIndex = value.standIndex + 1
            if (value.standIndex < 2) then
             -- DebugNote("skip - index:" .. value.index)
            else
             -- DebugNote("executing - index:" .. value.index)
              value.func()
              value.active = false            
            end
          else
            -- still moving.. reset index
            value.standIndex = 0
          end
        end
      end
      
      value.lastState = localState
      
      if (value.active == true) then
        isActive = true
      end
      
    end
    
    -- no timer items active.. disable
    if (isActive == false) then
      --DebugNote("disable timer")
      EnableTimer("execute_in_area_timer", false)
    end
  end

  local speed = "run"
    function move_trigger(name, line, wildcards)
    
    if (wildcards.roomid ~= "") then
      move(wildcards.roomid, wildcards.speed)
    end
    
  end
  
  function move(roomid, temp_speed)
  
    if (temp_speed == nil or temp_speed == "") then
      temp_speed = speed
    end
    if (temp_speed == "walk") then
      Note("walking to " .. roomid)
      Execute("mapper walkto " .. roomid)
    else
      Execute("mapper goto " .. roomid)
    end
  end
  -- function set_check_vidblain(name, line, wildcards)

  --   if (USER_check_vidblain == "true") then
  --   USER_check_vidblain = "false"
  --   else
  --   USER_check_vidblain = "true"
  --   end

  --   local msg = "off"
  --   if (USER_check_vidblain == "true") then
  --   msg = "on"
  --   end
  --   ColourNote ("darkorange", "", "No-portal vidblain assistance: " .. msg)
  -- end
  function sanitize_filename(str)
    str = string.gsub(str, "[^%w%s()_-]", "")
    return str
  end

]]>
</script>


</muclient>
